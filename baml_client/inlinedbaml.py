# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "clients.baml": "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\n\n// Using the new OpenAI Responses API for enhanced formatting\nclient<llm> CustomGPT5 {\n  provider openai-responses\n  options {\n    model \"gpt-5\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\nclient<llm> CustomGPT5Mini {\n  provider openai-responses\n  retry_policy Exponential\n  options {\n    model \"gpt-5-mini\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\n// Openai with chat completion\nclient<llm> CustomGPT5Chat {\n  provider openai\n  options {\n    model \"gpt-5\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\n// Latest Anthropic Claude 4 models\nclient<llm> CustomOpus4 {\n  provider anthropic\n  options {\n    model \"claude-opus-4-1-20250805\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\nclient<llm> CustomSonnet4 {\n  provider anthropic\n  options {\n    model \"claude-sonnet-4-20250514\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\nclient<llm> CustomHaiku {\n  provider anthropic\n  retry_policy Constant\n  options {\n    model \"claude-3-5-haiku-20241022\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\n// Google AI client for Sagebase (gemini-2.0-flash)\n// BAML automatically handles structured output based on function return types\nclient<llm> Gemini2Flash {\n  provider google-ai\n  retry_policy Exponential\n  options {\n    model \"gemini-2.0-flash\"\n    api_key env.GOOGLE_API_KEY\n  }\n}\n\n// Example AWS Bedrock client (uncomment to use)\n// client<llm> CustomBedrock {\n//   provider aws-bedrock\n//   options {\n//     model \"anthropic.claude-sonnet-4-20250514-v1:0\"\n//     region \"us-east-1\"\n//     // AWS credentials are auto-detected from env vars\n//   }\n// }\n\n// Example Azure OpenAI client (uncomment to use)\n// client<llm> CustomAzure {\n//   provider azure-openai\n//   options {\n//     model \"gpt-5\"\n//     api_key env.AZURE_OPENAI_API_KEY\n//     base_url \"https://MY_RESOURCE_NAME.openai.azure.com/openai/deployments/MY_DEPLOYMENT_ID\"\n//     api_version \"2024-10-01-preview\"\n//   }\n// }\n\n// Example Vertex AI client (uncomment to use)\n// client<llm> CustomVertex {\n//   provider vertex-ai\n//   options {\n//     model \"gemini-2.5-pro\"\n//     location \"us-central1\"\n//     // Uses Google Cloud Application Default Credentials\n//   }\n// }\n\n// Example Ollama client for local models (uncomment to use)\n// client<llm> CustomOllama {\n//   provider openai-generic\n//   options {\n//     base_url \"http://localhost:11434/v1\"\n//     model \"llama4\"\n//     default_role \"user\" // Most local models prefer the user role\n//     // No API key needed for local Ollama\n//   }\n// }\n\n// https://docs.boundaryml.com/docs/snippets/clients/round-robin\nclient<llm> CustomFast {\n  provider round-robin\n  options {\n    // This will alternate between the two clients\n    strategy [CustomGPT5Mini, CustomHaiku]\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/fallback\nclient<llm> OpenaiFallback {\n  provider fallback\n  options {\n    // This will try the clients in order until one succeeds\n    strategy [CustomGPT5Mini, CustomGPT5]\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/retry\nretry_policy Constant {\n  max_retries 3\n  strategy {\n    type constant_delay\n    delay_ms 200\n  }\n}\n\nretry_policy Exponential {\n  max_retries 2\n  strategy {\n    type exponential_backoff\n    delay_ms 300\n    multiplier 1.5\n    max_delay_ms 10000\n  }\n}\n",
    "generators.baml": "// This helps use auto generate libraries you can use in the language of\n// your choice. You can have multiple generators if you use multiple languages.\n// Just ensure that the output_dir is different for each generator.\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"python/pydantic\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../\"\n\n    // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\n    // The BAML VSCode extension version should also match this version.\n    version \"0.215.0\"\n\n    // Valid values: \"sync\", \"async\"\n    // This controls what `b.FunctionName()` will be (sync or async).\n    default_client_mode sync\n}\n",
    "link_classifier.baml": "// Link Classification for Sagebase\n// リンク分類用のBAML定義\n\n// ========================================\n// Class Definitions (Pydanticモデルに対応)\n// ========================================\n\n// LinkClassification - 個別リンクの分類結果\nclass LinkClassification {\n    url string @description(\"The URL being classified\")\n    link_type string @description(\"Type of link: prefecture_list, city_list, member_list, member_profile, other\")\n    confidence float @description(\"Confidence score (0.0-1.0)\")\n    reason string @description(\"Reason for classification\")\n}\n\n// ========================================\n// Function Definitions\n// ========================================\n\n// Function: リンクを分類\nfunction ClassifyLinks(\n    links: string,\n    party_name: string,\n    context: string\n) -> LinkClassification[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のリンクを分類してください。\n\n        リンク情報:\n        {{ links }}\n\n        政党名: {{ party_name }}\n        コンテキスト: {{ context }}\n\n        タスク:\n        各リンクを以下のタイプに分類してください:\n        - prefecture_list: 都道府県別リスト（例: 「北海道」「東京都」などのリンク）\n        - city_list: 市区町村別リスト（例: 「札幌市」「渋谷区」などのリンク）\n        - member_list: 議員一覧ページ（例: 「議員一覧」「メンバー紹介」などのリンク）\n        - member_profile: 議員個人ページ（例: 個別の議員名のリンク）\n        - other: その他のリンク\n\n        指示:\n        1. 各リンクのURL、テキスト、タイトルから適切なタイプを判定してください\n        2. URLは元のリンク情報から正確に抽出してください（改変しない）\n        3. confidenceは分類の確信度を0.0-1.0で表してください\n        4. reasonには判定理由を簡潔に説明してください（日本語で）\n\n        注意:\n        - URLは必ずリンク情報に含まれているものをそのまま使用してください\n        - リンクのテキストやタイトルが分類の重要な手がかりになります\n        - 政党名やコンテキストも考慮して分類してください\n\n        出力形式（JSON配列）:\n        [\n          {\n            \"url\": \"https://example.com/link1\",\n            \"link_type\": \"member_list\",\n            \"confidence\": 0.95,\n            \"reason\": \"「議員一覧」というテキストから議員リストページと判断\"\n          },\n          {\n            \"url\": \"https://example.com/link2\",\n            \"link_type\": \"prefecture_list\",\n            \"confidence\": 0.88,\n            \"reason\": \"「北海道」というテキストから都道府県リストと判断\"\n          }\n        ]\n    \"#\n}\n",
    "member_extraction.baml": "// Conference Member Extraction for Sagebase\n// 会議体メンバー抽出用のBAML定義\n\n// 抽出されたメンバー情報の型定義\nclass ExtractedMember {\n    name string @description(\"議員名（フルネーム）\")\n    role string? @description(\"役職（議長、副議長、委員長、委員など）\")\n    party_name string? @description(\"所属政党名\")\n    additional_info string? @description(\"その他の情報\")\n}\n\n// メンバー抽出関数\nfunction ExtractMembers(\n    html: string,\n    conference_name: string\n) -> ExtractedMember[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のHTMLから{{ conference_name }}の議員メンバー情報を抽出してください。\n\n        重要: このページに複数の委員会や議会の情報が含まれている場合、\n        必ず「{{ conference_name }}」に所属する議員のみを抽出してください。\n        他の委員会や議会のメンバーは抽出しないでください。\n\n        HTMLコンテンツ:\n        {{ html }}\n\n        抽出する情報:\n        1. 議員名（フルネーム）\n        2. 役職（議長、副議長、委員長、副委員長、委員など）\n        3. 所属政党名（わかる場合）\n        4. その他の重要な情報\n\n        注意事項:\n        - 議員名は姓名を正確に抽出してください\n        - 敬称（議員、氏、さん、様、先生など）は除外してください\n        - 役職がない場合は「委員」としてください\n        - 所属政党が明記されていない場合はnullとしてください\n        - 複数の役職がある場合は主要な役職を選択してください\n        - 必ず指定された「{{ conference_name }}」に関連する議員のみを抽出し、\n          他の委員会や議会のメンバーは含めないでください\n    \"#\n}\n",
    "minutes_divider.baml": "// Minutes Divider for Sagebase\n// 議事録分割処理用のBAML定義\n\n// ========================================\n// Class Definitions (Pydanticモデルに対応)\n// ========================================\n\n// 1. SectionInfo - 分割されたセクションの情報\nclass SectionInfo {\n    chapter_number int @description(\"分割した文字列を前から順に割り振った番号\")\n    keyword string @description(\"分割した文字列の先頭30文字をそのまま抽出した文字列\")\n}\n\n// 2. SectionString - 分割されたセクションの文字列\nclass SectionString {\n    chapter_number int @description(\"分割した文字列を前から順に割り振った番号\")\n    sub_chapter_number int @description(\"再分割した場合の文字列番号\")\n    section_string string @description(\"分割した文字列\")\n}\n\n// 3. RedividedSectionInfo - 再分割されたセクションの情報\nclass RedividedSectionInfo {\n    chapter_number int @description(\"再分割前の順番を表す番号\")\n    sub_chapter_number int @description(\"再分割した中での順番を表す番号\")\n    keyword string @description(\"分割した文字列の先頭30文字をそのまま抽出した文字列\")\n}\n\n// 4. SpeakerAndSpeechContent - 発言者と発言内容\nclass SpeakerAndSpeechContent {\n    speaker string @description(\"発言者\")\n    speech_content string @description(\"発言内容\")\n    chapter_number int @description(\"分割した文字列を前から順に割り振った番号\")\n    sub_chapter_number int @description(\"再分割した場合の文字列番号\")\n    speech_order int @description(\"発言順\")\n}\n\n// 5. MinutesBoundary - 議事録の境界検出結果\nclass MinutesBoundary {\n    boundary_found bool @description(\"境界が見つかったかどうか\")\n    boundary_text string? @description(\"境界前後の文字列（｜境界｜でマーク）\")\n    boundary_type string @description(\"境界の種類: separator_line, speech_start, time_marker, none\")\n    confidence float @description(\"境界検出の信頼度（0.0-1.0）\")\n    reason string @description(\"境界判定の理由\")\n}\n\n// 6. AttendeesMapping - 出席者の役職と名前のマッピング\nclass AttendeesMapping {\n    attendees_mapping map<string, string?>? @description(\"役職から人名へのマッピング（使用しない場合はnull）\")\n    regular_attendees string[] @description(\"出席者の人名リスト\")\n    confidence float @description(\"抽出の信頼度（0.0-1.0）\")\n}\n\n// ========================================\n// Function Definitions\n// ========================================\n\n// Function 1: 議事録を章に分割してキーワードリストを返す\nfunction DivideMinutesToKeywords(minutes: string) -> SectionInfo[] {\n    client Gemini2Flash\n    prompt #\"\n        以下の議事録を意味のあるセクション（章）に分割して、各セクションの先頭キーワードを抽出してください。\n\n        議事録:\n        {{ minutes }}\n\n        指示:\n        1. 議事録を意味のある単位で分割してください（発言者の変更、議題の変更など）\n        2. 各セクションの先頭30文字をキーワードとして抽出してください\n        3. chapter_numberは1から順番に割り振ってください\n        4. キーワードは元の文字列から正確に抽出してください（改変しない）\n        5. できるだけ多くのセクションに分割してください（目安: 5-30セクション）\n\n        注意:\n        - キーワードは議事録内に実際に存在する文字列である必要があります\n        - キーワードは先頭から正確に30文字抽出してください（30文字未満の場合は全文）\n\n        出力形式（JSON配列）:\n        [\n          {\n            \"chapter_number\": 1,\n            \"keyword\": \"先頭30文字のキーワード\"\n          },\n          {\n            \"chapter_number\": 2,\n            \"keyword\": \"次のセクションの先頭30文字\"\n          }\n        ]\n\n        重要: \"keyword\"フィールドを使用してください（\"keywords\"ではありません）\n    \"#\n}\n\n// Function 2: 出席者情報と発言部分の境界を検出\nfunction DetectBoundary(minutes_text: string) -> MinutesBoundary {\n    client Gemini2Flash\n    prompt #\"\n        以下の議事録テキストから、出席者情報と発言部分の境界を検出してください。\n\n        議事録テキスト:\n        {{ minutes_text }}\n\n        指示:\n        1. 出席者リストや役員名簿と、実際の発言内容の境界を見つけてください\n        2. 境界が見つかった場合、boundary_foundをtrueにしてください\n        3. boundary_textには境界前後のテキストを「｜境界｜」でマークして返してください\n           - 境界の前20文字 + ｜境界｜ + 境界の後20文字 の形式\n        4. boundary_typeは以下のいずれか:\n           - separator_line: 区切り線（---、===など）で区切られている\n           - speech_start: 発言開始パターン（○、◆など）で区切られている\n           - time_marker: 時刻表記で区切られている\n           - none: 境界が見つからない\n        5. confidenceは境界検出の確信度（0.0-1.0）\n        6. reasonには判定理由を簡潔に説明してください\n\n        境界が見つからない場合:\n        - boundary_found=false\n        - boundary_text=null\n        - boundary_type=\"none\"\n        - confidence=0.0\n    \"#\n}\n\n// Function 3: 出席者情報を抽出\nfunction ExtractAttendees(attendees_text: string) -> AttendeesMapping {\n    client Gemini2Flash\n    prompt #\"\n        以下の出席者情報テキストから、役職と人名のマッピングを抽出してください。\n\n        出席者情報:\n        {{ attendees_text }}\n\n        指示:\n        1. 役職と人名の対応関係を抽出してください（例: \"議長\" -> \"山田太郎\"）\n        2. regular_attendeesには全ての出席者の名前をリストで返してください\n        3. 敬称（議員、氏、さん、様、先生など）は除外してください\n        4. confidenceは抽出の確信度（0.0-1.0）\n        5. attendees_mappingは役職が明確な場合のみ設定し、不明な場合はnullとしてください\n\n        注意:\n        - 人名は姓名を正確に抽出してください\n        - 同じ人物が複数回出現する場合は重複を除いてください\n    \"#\n}\n\n// Function 4: 発言者と発言内容に分割\nfunction DivideSpeech(section_string: string) -> SpeakerAndSpeechContent[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のセクションテキストから、発言者と発言内容を抽出してください。\n\n        セクション内容:\n        {{ section_string }}\n\n        指示:\n        1. 各発言を発言者と発言内容に分割してください\n        2. 発言者名は正確に抽出してください（敬称を除く）\n        3. speech_orderは1から順番に割り振ってください\n        4. chapter_numberとsub_chapter_numberは1に設定してください（後で更新されます）\n        5. 発言内容は発言者の発言部分のみを含めてください\n\n        国会議事録の一般的なフォーマット:\n        - ○議長（名前）発言内容\n        - ◆議員（名前）発言内容\n        - ○委員長（名前）発言内容\n\n        注意:\n        - 発言者が明示されていない場合でも、文脈から推測して抽出してください\n        - 発言内容は元のテキストから正確に抽出してください\n\n        出力形式（JSON配列）:\n        [\n          {\n            \"speaker\": \"発言者名（敬称なし）\",\n            \"speech_content\": \"発言内容\",\n            \"chapter_number\": 1,\n            \"sub_chapter_number\": 1,\n            \"speech_order\": 1\n          },\n          {\n            \"speaker\": \"次の発言者名\",\n            \"speech_content\": \"次の発言内容\",\n            \"chapter_number\": 1,\n            \"sub_chapter_number\": 1,\n            \"speech_order\": 2\n          }\n        ]\n\n        重要: \"speech_content\"フィールドを使用してください（\"utterance\", \"speech\"ではありません）\n    \"#\n}\n\n// Function 5: 長いセクションを再分割\nfunction RedivideSection(section_text: string, divide_counter: int, original_index: int) -> SectionInfo[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のセクションを{{ divide_counter }}個に再分割してください。\n\n        元のインデックス: {{ original_index }}\n\n        セクション内容:\n        {{ section_text }}\n\n        指示:\n        1. セクションを{{ divide_counter }}個の意味のある単位に分割してください\n        2. 各セクションの先頭30文字をキーワードとして抽出してください\n        3. chapter_numberは1から順番に割り振ってください\n        4. キーワードは元の文字列から正確に抽出してください（改変しない）\n\n        注意:\n        - 意味のある区切りで分割してください（発言者の変更、議題の変更など）\n        - キーワードは議事録内に実際に存在する文字列である必要があります\n    \"#\n}\n",
    "page_classifier.baml": "// Page Classification for Sagebase\n// ページ分類用のBAML定義\n\n// ========================================\n// Class Definitions (Pydanticモデルに対応)\n// ========================================\n\n// PageClassification - ページタイプの分類結果\nclass PageClassification {\n    page_type string @description(\"Type of page: index_page, member_list_page, other\")\n    confidence float @description(\"Confidence score (0.0-1.0)\")\n    reason string @description(\"Reason for classification\")\n    has_child_links bool @description(\"Whether the page has child links\")\n    has_member_info bool @description(\"Whether the page has member information\")\n}\n\n// ========================================\n// Function Definitions\n// ========================================\n\n// Function: ページを分類\nfunction ClassifyPage(\n    html_excerpt: string,\n    current_url: string,\n    party_name: string\n) -> PageClassification {\n    client Gemini2Flash\n    prompt #\"\n        以下のWebページを分類してください。\n\n        URL: {{ current_url }}\n        政党名: {{ party_name }}\n\n        HTMLの一部（抜粋）:\n        {{ html_excerpt }}\n\n        タスク:\n        このページを以下のタイプに分類してください:\n        - index_page: インデックスページ（他のページへのリンク集、ナビゲーションページ）\n        - member_list_page: 議員一覧ページ（議員の情報が掲載されているページ）\n        - other: その他のページ\n\n        指示:\n        1. HTMLの内容から適切なページタイプを判定してください\n        2. has_child_links: このページに子ページへのリンクがあるかを判定（true/false）\n        3. has_member_info: このページに議員情報が含まれているかを判定（true/false）\n        4. confidence: 分類の確信度を0.0-1.0で表してください\n        5. reason: 判定理由を簡潔に説明してください（日本語で）\n\n        判定のポイント:\n        - インデックスページ: 「都道府県一覧」「支部一覧」「地域別」などのナビゲーションリンクが多い\n        - 議員一覧ページ: 議員名、役職、連絡先、プロフィールなどの情報が複数含まれている\n        - その他: 上記に該当しない一般的なページ\n\n        注意:\n        - URLやHTMLの構造から総合的に判断してください\n        - 政党名も判定の参考にしてください\n        - HTMLは抜粋なので、完全な情報がない場合もあります\n\n        出力形式（JSON）:\n        {\n          \"page_type\": \"index_page\",\n          \"confidence\": 0.92,\n          \"reason\": \"「都道府県別」「支部一覧」などのナビゲーションリンクが多数含まれているため、インデックスページと判断\",\n          \"has_child_links\": true,\n          \"has_member_info\": false\n        }\n    \"#\n}\n",
    "parliamentary_group_member_extractor.baml": "// Parliamentary Group Member Extraction for Sagebase\n// 議員団メンバー抽出用のBAML定義\n\n// 抽出された議員団メンバー情報の型定義\nclass ParliamentaryGroupMember {\n    name string @description(\"議員名（フルネーム）\")\n    role string? @description(\"役職（団長、幹事長、政調会長など）\")\n    party_name string? @description(\"所属政党名\")\n    district string? @description(\"選挙区\")\n    additional_info string? @description(\"その他の情報\")\n}\n\n// 議員団メンバー抽出関数\nfunction ExtractParliamentaryGroupMembers(\n    html: string,\n    text_content: string\n) -> ParliamentaryGroupMember[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のWebページから議員団に所属する議員の情報を抽出してください。\n\n        各議員について以下の情報を抽出:\n        1. 議員の氏名（必須、フルネーム）\n        2. 議員団内での役職（団長、幹事長、政調会長など）\n        3. 所属政党名（議員団名とは異なる場合のみ）\n        4. 選挙区\n        5. その他の重要な情報\n\n        注意事項:\n        - 議員団（会派）のメンバー一覧を抽出してください\n        - 役職者だけでなく、一般のメンバーも含めて全員を抽出してください\n        - 名前の表記は元のページの表記を維持してください\n        - 敬称（議員、氏、さん、様、先生など）は除外してください\n        - 議員団名と政党名は異なる場合があります（例：「○○会派」と「△△党」）\n        - 役職がない場合はnullとしてください\n        - 所属政党が明記されていない場合はnullとしてください\n\n        **重要: 必ず以下の英語フィールド名でJSONを返してください:**\n        - name: 議員名\n        - role: 役職\n        - party_name: 所属政党名\n        - district: 選挙区\n        - additional_info: その他の情報\n\n        テキストコンテンツ:\n        {{ text_content }}\n\n        HTMLコンテンツ（構造の参考用）:\n        {{ html }}\n\n        上記の情報から、議員団メンバー全員の情報を抽出してください。\n    \"#\n}\n",
    "party_member_extractor.baml": "// Party Member Extraction for Sagebase\n// 政党メンバー抽出用のBAML定義\n\n// 抽出された政党メンバー情報の型定義\nclass ExtractedPartyMember {\n    name string @description(\"議員の氏名（姓名、敬称なし）\")\n    position string? @description(\"役職（衆議院議員、参議院議員、市議会議員、区議会議員、県議会議員など）\")\n    electoral_district string? @description(\"選挙区（例：東京1区、比例北海道、渋谷区、盛岡市など）\")\n    prefecture string? @description(\"都道府県（例：東京都、北海道）\")\n    profile_url string? @description(\"プロフィールページのURL（相対URLまたは絶対URL）\")\n    party_position string? @description(\"党内役職（代表、幹事長など）\")\n}\n\n// 政党メンバー抽出関数\nfunction ExtractPartyMembers(\n    content: string,\n    party_name: string,\n    base_url: string\n) -> ExtractedPartyMember[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のコンテンツから{{ party_name }}の議員メンバー情報を抽出してください。\n\n        重要事項:\n        - 議員名は姓名を正確に抽出してください（姓と名の間にスペースは不要）\n        - 敬称（議員、氏、さん、様、先生など）は除外してください\n        - プロフィールURLは以下のルールで抽出してください：\n          * HTMLの<a>タグのhref属性から取得してください\n          * 「プロフィール」「詳細」などのテキストそのものをURLにしないでください\n          * 相対URLの場合は、基準URL {{ base_url }} と結合した絶対URLにしてください\n          * リンクが見つからない場合はnullを設定してください\n        - データが不明な場合はnullを設定してください\n        - 議員ではない人物（事務局スタッフなど）は除外してください\n\n        コンテンツ:\n        {{ content }}\n\n        以下のJSON形式で出力してください（スキーマのフィールド名を正確に使用）：\n        - name: 議員の氏名（姓名、敬称なし、必須）\n        - position: 役職（衆議院議員、参議院議員、市議会議員など）\n        - electoral_district: 選挙区（東京1区、比例北海道、渋谷区など）\n        - prefecture: 都道府県（東京都、北海道など）\n        - profile_url: プロフィールページのURL（<a>タグのhrefから抽出、絶対URL形式）\n        - party_position: 党内役職（代表、幹事長など）\n\n        ※不明な項目はnullとしてください\n    \"#\n}\n",
    "resume.baml": "// Defining a data model.\nclass Resume {\n  name string\n  email string\n  experience string[]\n  skills string[]\n}\n\n// Create a function to extract the resume from a string.\nfunction ExtractResume(resume: string) -> Resume {\n  // Specify a client as provider/model-name\n  // You can also use custom LLM params with a custom client name from clients.baml like \"client CustomGPT5\" or \"client CustomSonnet4\"\n  client \"openai-responses/gpt-5-mini\" // Set OPENAI_API_KEY to use this client.\n  prompt #\"\n    Extract from this content:\n    {{ resume }}\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n\n\n// Test the function with a sample resume. Open the VSCode playground to run this.\ntest vaibhav_resume {\n  functions [ExtractResume]\n  args {\n    resume #\"\n      Vaibhav Gupta\n      vbv@boundaryml.com\n\n      Experience:\n      - Founder at BoundaryML\n      - CV Engineer at Google\n      - CV Engineer at Microsoft\n\n      Skills:\n      - Rust\n      - C++\n    \"#\n  }\n}\n",
}

def get_baml_files():
    return _file_map
