# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "clients.baml": "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\n\n// Using the new OpenAI Responses API for enhanced formatting\nclient<llm> CustomGPT5 {\n  provider openai-responses\n  options {\n    model \"gpt-5\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\nclient<llm> CustomGPT5Mini {\n  provider openai-responses\n  retry_policy Exponential\n  options {\n    model \"gpt-5-mini\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\n// Openai with chat completion\nclient<llm> CustomGPT5Chat {\n  provider openai\n  options {\n    model \"gpt-5\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\n// Latest Anthropic Claude 4 models\nclient<llm> CustomOpus4 {\n  provider anthropic\n  options {\n    model \"claude-opus-4-1-20250805\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\nclient<llm> CustomSonnet4 {\n  provider anthropic\n  options {\n    model \"claude-sonnet-4-20250514\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\nclient<llm> CustomHaiku {\n  provider anthropic\n  retry_policy Constant\n  options {\n    model \"claude-3-5-haiku-20241022\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\n// Google AI client for Sagebase (gemini-2.0-flash)\nclient<llm> Gemini2Flash {\n  provider google-ai\n  retry_policy Exponential\n  options {\n    model \"gemini-2.0-flash\"\n    api_key env.GOOGLE_API_KEY\n  }\n}\n\n// Example AWS Bedrock client (uncomment to use)\n// client<llm> CustomBedrock {\n//   provider aws-bedrock\n//   options {\n//     model \"anthropic.claude-sonnet-4-20250514-v1:0\"\n//     region \"us-east-1\"\n//     // AWS credentials are auto-detected from env vars\n//   }\n// }\n\n// Example Azure OpenAI client (uncomment to use)\n// client<llm> CustomAzure {\n//   provider azure-openai\n//   options {\n//     model \"gpt-5\"\n//     api_key env.AZURE_OPENAI_API_KEY\n//     base_url \"https://MY_RESOURCE_NAME.openai.azure.com/openai/deployments/MY_DEPLOYMENT_ID\"\n//     api_version \"2024-10-01-preview\"\n//   }\n// }\n\n// Example Vertex AI client (uncomment to use)\n// client<llm> CustomVertex {\n//   provider vertex-ai\n//   options {\n//     model \"gemini-2.5-pro\"\n//     location \"us-central1\"\n//     // Uses Google Cloud Application Default Credentials\n//   }\n// }\n\n// Example Ollama client for local models (uncomment to use)\n// client<llm> CustomOllama {\n//   provider openai-generic\n//   options {\n//     base_url \"http://localhost:11434/v1\"\n//     model \"llama4\"\n//     default_role \"user\" // Most local models prefer the user role\n//     // No API key needed for local Ollama\n//   }\n// }\n\n// https://docs.boundaryml.com/docs/snippets/clients/round-robin\nclient<llm> CustomFast {\n  provider round-robin\n  options {\n    // This will alternate between the two clients\n    strategy [CustomGPT5Mini, CustomHaiku]\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/fallback\nclient<llm> OpenaiFallback {\n  provider fallback\n  options {\n    // This will try the clients in order until one succeeds\n    strategy [CustomGPT5Mini, CustomGPT5]\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/retry\nretry_policy Constant {\n  max_retries 3\n  strategy {\n    type constant_delay\n    delay_ms 200\n  }\n}\n\nretry_policy Exponential {\n  max_retries 2\n  strategy {\n    type exponential_backoff\n    delay_ms 300\n    multiplier 1.5\n    max_delay_ms 10000\n  }\n}\n",
    "generators.baml": "// This helps use auto generate libraries you can use in the language of\n// your choice. You can have multiple generators if you use multiple languages.\n// Just ensure that the output_dir is different for each generator.\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"python/pydantic\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../\"\n\n    // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\n    // The BAML VSCode extension version should also match this version.\n    version \"0.214.0\"\n\n    // Valid values: \"sync\", \"async\"\n    // This controls what `b.FunctionName()` will be (sync or async).\n    default_client_mode sync\n}\n",
    "member_extraction.baml": "// Conference Member Extraction for Sagebase\n// 会議体メンバー抽出用のBAML定義\n\n// 抽出されたメンバー情報の型定義\nclass ExtractedMember {\n    name string @description(\"議員名（フルネーム）\")\n    role string? @description(\"役職（議長、副議長、委員長、委員など）\")\n    party_name string? @description(\"所属政党名\")\n    additional_info string? @description(\"その他の情報\")\n}\n\n// メンバー抽出関数\nfunction ExtractMembers(\n    html: string,\n    conference_name: string\n) -> ExtractedMember[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のHTMLから{{ conference_name }}の議員メンバー情報を抽出してください。\n\n        重要: このページに複数の委員会や議会の情報が含まれている場合、\n        必ず「{{ conference_name }}」に所属する議員のみを抽出してください。\n        他の委員会や議会のメンバーは抽出しないでください。\n\n        HTMLコンテンツ:\n        {{ html }}\n\n        抽出する情報:\n        1. 議員名（フルネーム）\n        2. 役職（議長、副議長、委員長、副委員長、委員など）\n        3. 所属政党名（わかる場合）\n        4. その他の重要な情報\n\n        注意事項:\n        - 議員名は姓名を正確に抽出してください\n        - 敬称（議員、氏、さん、様、先生など）は除外してください\n        - 役職がない場合は「委員」としてください\n        - 所属政党が明記されていない場合はnullとしてください\n        - 複数の役職がある場合は主要な役職を選択してください\n        - 必ず指定された「{{ conference_name }}」に関連する議員のみを抽出し、\n          他の委員会や議会のメンバーは含めないでください\n    \"#\n}\n",
    "minutes_divider.baml": "// Minutes Divider for Sagebase\n// 議事録分割処理用のBAML定義\n\n// ========================================\n// Class Definitions (Pydanticモデルに対応)\n// ========================================\n\n// 1. SectionInfo - 分割されたセクションの情報\nclass SectionInfo {\n    chapter_number int @description(\"分割した文字列を前から順に割り振った番号\")\n    keyword string @description(\"分割した文字列の先頭30文字をそのまま抽出した文字列\")\n}\n\n// 2. SectionString - 分割されたセクションの文字列\nclass SectionString {\n    chapter_number int @description(\"分割した文字列を前から順に割り振った番号\")\n    sub_chapter_number int @description(\"再分割した場合の文字列番号\")\n    section_string string @description(\"分割した文字列\")\n}\n\n// 3. RedividedSectionInfo - 再分割されたセクションの情報\nclass RedividedSectionInfo {\n    chapter_number int @description(\"再分割前の順番を表す番号\")\n    sub_chapter_number int @description(\"再分割した中での順番を表す番号\")\n    keyword string @description(\"分割した文字列の先頭30文字をそのまま抽出した文字列\")\n}\n\n// 4. SpeakerAndSpeechContent - 発言者と発言内容\nclass SpeakerAndSpeechContent {\n    speaker string @description(\"発言者\")\n    speech_content string @description(\"発言内容\")\n    chapter_number int @description(\"分割した文字列を前から順に割り振った番号\")\n    sub_chapter_number int @description(\"再分割した場合の文字列番号\")\n    speech_order int @description(\"発言順\")\n}\n\n// 5. MinutesBoundary - 議事録の境界検出結果\nclass MinutesBoundary {\n    boundary_found bool @description(\"境界が見つかったかどうか\")\n    boundary_text string? @description(\"境界前後の文字列（｜境界｜でマーク）\")\n    boundary_type string @description(\"境界の種類: separator_line, speech_start, time_marker, none\")\n    confidence float @description(\"境界検出の信頼度（0.0-1.0）\")\n    reason string @description(\"境界判定の理由\")\n}\n\n// 6. AttendeesMapping - 出席者の役職と名前のマッピング\nclass AttendeesMapping {\n    attendees_mapping map<string, string?>? @description(\"役職から人名へのマッピング（使用しない場合はnull）\")\n    regular_attendees string[] @description(\"出席者の人名リスト\")\n    confidence float @description(\"抽出の信頼度（0.0-1.0）\")\n}\n\n// ========================================\n// Function Definitions\n// ========================================\n\n// Function 1: 議事録を章に分割してキーワードリストを返す\nfunction DivideMinutesToKeywords(minutes: string) -> SectionInfo[] {\n    client Gemini2Flash\n    prompt #\"\n        以下の議事録を意味のあるセクション（章）に分割して、各セクションの先頭キーワードを抽出してください。\n\n        議事録:\n        {{ minutes }}\n\n        指示:\n        1. 議事録を意味のある単位で分割してください（発言者の変更、議題の変更など）\n        2. 各セクションの先頭30文字をキーワードとして抽出してください\n        3. chapter_numberは1から順番に割り振ってください\n        4. キーワードは元の文字列から正確に抽出してください（改変しない）\n        5. できるだけ多くのセクションに分割してください（目安: 5-30セクション）\n\n        注意:\n        - キーワードは議事録内に実際に存在する文字列である必要があります\n        - キーワードは先頭から正確に30文字抽出してください（30文字未満の場合は全文）\n\n        出力形式（JSON配列）:\n        [\n          {\n            \"chapter_number\": 1,\n            \"keyword\": \"先頭30文字のキーワード\"\n          },\n          {\n            \"chapter_number\": 2,\n            \"keyword\": \"次のセクションの先頭30文字\"\n          }\n        ]\n\n        重要: \"keyword\"フィールドを使用してください（\"keywords\"ではありません）\n    \"#\n}\n\n// Function 2: 出席者情報と発言部分の境界を検出\nfunction DetectBoundary(minutes_text: string) -> MinutesBoundary {\n    client Gemini2Flash\n    prompt #\"\n        以下の議事録テキストから、出席者情報と発言部分の境界を検出してください。\n\n        議事録テキスト:\n        {{ minutes_text }}\n\n        指示:\n        1. 出席者リストや役員名簿と、実際の発言内容の境界を見つけてください\n        2. 境界が見つかった場合、boundary_foundをtrueにしてください\n        3. boundary_textには境界前後のテキストを「｜境界｜」でマークして返してください\n           - 境界の前20文字 + ｜境界｜ + 境界の後20文字 の形式\n        4. boundary_typeは以下のいずれか:\n           - separator_line: 区切り線（---、===など）で区切られている\n           - speech_start: 発言開始パターン（○、◆など）で区切られている\n           - time_marker: 時刻表記で区切られている\n           - none: 境界が見つからない\n        5. confidenceは境界検出の確信度（0.0-1.0）\n        6. reasonには判定理由を簡潔に説明してください\n\n        境界が見つからない場合:\n        - boundary_found=false\n        - boundary_text=null\n        - boundary_type=\"none\"\n        - confidence=0.0\n    \"#\n}\n\n// Function 3: 出席者情報を抽出\nfunction ExtractAttendees(attendees_text: string) -> AttendeesMapping {\n    client Gemini2Flash\n    prompt #\"\n        以下の出席者情報テキストから、役職と人名のマッピングを抽出してください。\n\n        出席者情報:\n        {{ attendees_text }}\n\n        指示:\n        1. 役職と人名の対応関係を抽出してください（例: \"議長\" -> \"山田太郎\"）\n        2. regular_attendeesには全ての出席者の名前をリストで返してください\n        3. 敬称（議員、氏、さん、様、先生など）は除外してください\n        4. confidenceは抽出の確信度（0.0-1.0）\n        5. attendees_mappingは役職が明確な場合のみ設定し、不明な場合はnullとしてください\n\n        注意:\n        - 人名は姓名を正確に抽出してください\n        - 同じ人物が複数回出現する場合は重複を除いてください\n    \"#\n}\n\n// Function 4: 発言者と発言内容に分割\nfunction DivideSpeech(section_string: string) -> SpeakerAndSpeechContent[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のセクションテキストから、発言者と発言内容を抽出してください。\n\n        セクション内容:\n        {{ section_string }}\n\n        指示:\n        1. 各発言を発言者と発言内容に分割してください\n        2. 発言者名は正確に抽出してください（敬称を除く）\n        3. speech_orderは1から順番に割り振ってください\n        4. chapter_numberとsub_chapter_numberは1に設定してください（後で更新されます）\n        5. 発言内容は発言者の発言部分のみを含めてください\n\n        国会議事録の一般的なフォーマット:\n        - ○議長（名前）発言内容\n        - ◆議員（名前）発言内容\n        - ○委員長（名前）発言内容\n\n        注意:\n        - 発言者が明示されていない場合でも、文脈から推測して抽出してください\n        - 発言内容は元のテキストから正確に抽出してください\n\n        出力形式（JSON配列）:\n        [\n          {\n            \"speaker\": \"発言者名（敬称なし）\",\n            \"speech_content\": \"発言内容\",\n            \"chapter_number\": 1,\n            \"sub_chapter_number\": 1,\n            \"speech_order\": 1\n          },\n          {\n            \"speaker\": \"次の発言者名\",\n            \"speech_content\": \"次の発言内容\",\n            \"chapter_number\": 1,\n            \"sub_chapter_number\": 1,\n            \"speech_order\": 2\n          }\n        ]\n\n        重要: \"speech_content\"フィールドを使用してください（\"utterance\", \"speech\"ではありません）\n    \"#\n}\n\n// Function 5: 長いセクションを再分割\nfunction RedivideSection(section_text: string, divide_counter: int, original_index: int) -> SectionInfo[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のセクションを{{ divide_counter }}個に再分割してください。\n\n        元のインデックス: {{ original_index }}\n\n        セクション内容:\n        {{ section_text }}\n\n        指示:\n        1. セクションを{{ divide_counter }}個の意味のある単位に分割してください\n        2. 各セクションの先頭30文字をキーワードとして抽出してください\n        3. chapter_numberは1から順番に割り振ってください\n        4. キーワードは元の文字列から正確に抽出してください（改変しない）\n\n        注意:\n        - 意味のある区切りで分割してください（発言者の変更、議題の変更など）\n        - キーワードは議事録内に実際に存在する文字列である必要があります\n    \"#\n}\n",
    "parliamentary_group_member_extractor.baml": "// Parliamentary Group Member Extraction for Sagebase\n// 議員団メンバー抽出用のBAML定義\n\n// 抽出された議員団メンバー情報の型定義\nclass ParliamentaryGroupMember {\n    name string @description(\"議員名（フルネーム）\")\n    role string? @description(\"役職（団長、幹事長、政調会長など）\")\n    party_name string? @description(\"所属政党名\")\n    district string? @description(\"選挙区\")\n    additional_info string? @description(\"その他の情報\")\n}\n\n// 議員団メンバー抽出関数\nfunction ExtractParliamentaryGroupMembers(\n    html: string,\n    text_content: string\n) -> ParliamentaryGroupMember[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のWebページから議員団に所属する議員の情報を抽出してください。\n\n        各議員について以下の情報を抽出:\n        1. 議員の氏名（必須、フルネーム）\n        2. 議員団内での役職（団長、幹事長、政調会長など）\n        3. 所属政党名（議員団名とは異なる場合のみ）\n        4. 選挙区\n        5. その他の重要な情報\n\n        注意事項:\n        - 議員団（会派）のメンバー一覧を抽出してください\n        - 役職者だけでなく、一般のメンバーも含めて全員を抽出してください\n        - 名前の表記は元のページの表記を維持してください\n        - 敬称（議員、氏、さん、様、先生など）は除外してください\n        - 議員団名と政党名は異なる場合があります（例：「○○会派」と「△△党」）\n        - 役職がない場合はnullとしてください\n        - 所属政党が明記されていない場合はnullとしてください\n\n        テキストコンテンツ:\n        {{ text_content }}\n\n        HTMLコンテンツ（構造の参考用）:\n        {{ html }}\n\n        上記の情報から、議員団メンバー全員の情報を抽出してください。\n    \"#\n}\n",
    "resume.baml": "// Defining a data model.\nclass Resume {\n  name string\n  email string\n  experience string[]\n  skills string[]\n}\n\n// Create a function to extract the resume from a string.\nfunction ExtractResume(resume: string) -> Resume {\n  // Specify a client as provider/model-name\n  // You can also use custom LLM params with a custom client name from clients.baml like \"client CustomGPT5\" or \"client CustomSonnet4\"\n  client \"openai-responses/gpt-5-mini\" // Set OPENAI_API_KEY to use this client.\n  prompt #\"\n    Extract from this content:\n    {{ resume }}\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n\n\n// Test the function with a sample resume. Open the VSCode playground to run this.\ntest vaibhav_resume {\n  functions [ExtractResume]\n  args {\n    resume #\"\n      Vaibhav Gupta\n      vbv@boundaryml.com\n\n      Experience:\n      - Founder at BoundaryML\n      - CV Engineer at Google\n      - CV Engineer at Microsoft\n\n      Skills:\n      - Rust\n      - C++\n    \"#\n  }\n}\n",
}

def get_baml_files():
    return _file_map
