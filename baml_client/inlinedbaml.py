# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "clients.baml": "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\n\n// Using the new OpenAI Responses API for enhanced formatting\nclient<llm> CustomGPT5 {\n  provider openai-responses\n  options {\n    model \"gpt-5\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\nclient<llm> CustomGPT5Mini {\n  provider openai-responses\n  retry_policy Exponential\n  options {\n    model \"gpt-5-mini\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\n// Openai with chat completion\nclient<llm> CustomGPT5Chat {\n  provider openai\n  options {\n    model \"gpt-5\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\n// Latest Anthropic Claude 4 models\nclient<llm> CustomOpus4 {\n  provider anthropic\n  options {\n    model \"claude-opus-4-1-20250805\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\nclient<llm> CustomSonnet4 {\n  provider anthropic\n  options {\n    model \"claude-sonnet-4-20250514\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\nclient<llm> CustomHaiku {\n  provider anthropic\n  retry_policy Constant\n  options {\n    model \"claude-3-5-haiku-20241022\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\n// Google AI client for Sagebase (gemini-2.0-flash)\n// BAML automatically handles structured output based on function return types\nclient<llm> Gemini2Flash {\n  provider google-ai\n  retry_policy Exponential\n  options {\n    model \"gemini-2.0-flash\"\n    api_key env.GOOGLE_API_KEY\n  }\n}\n\n// Example AWS Bedrock client (uncomment to use)\n// client<llm> CustomBedrock {\n//   provider aws-bedrock\n//   options {\n//     model \"anthropic.claude-sonnet-4-20250514-v1:0\"\n//     region \"us-east-1\"\n//     // AWS credentials are auto-detected from env vars\n//   }\n// }\n\n// Example Azure OpenAI client (uncomment to use)\n// client<llm> CustomAzure {\n//   provider azure-openai\n//   options {\n//     model \"gpt-5\"\n//     api_key env.AZURE_OPENAI_API_KEY\n//     base_url \"https://MY_RESOURCE_NAME.openai.azure.com/openai/deployments/MY_DEPLOYMENT_ID\"\n//     api_version \"2024-10-01-preview\"\n//   }\n// }\n\n// Example Vertex AI client (uncomment to use)\n// client<llm> CustomVertex {\n//   provider vertex-ai\n//   options {\n//     model \"gemini-2.5-pro\"\n//     location \"us-central1\"\n//     // Uses Google Cloud Application Default Credentials\n//   }\n// }\n\n// Example Ollama client for local models (uncomment to use)\n// client<llm> CustomOllama {\n//   provider openai-generic\n//   options {\n//     base_url \"http://localhost:11434/v1\"\n//     model \"llama4\"\n//     default_role \"user\" // Most local models prefer the user role\n//     // No API key needed for local Ollama\n//   }\n// }\n\n// https://docs.boundaryml.com/docs/snippets/clients/round-robin\nclient<llm> CustomFast {\n  provider round-robin\n  options {\n    // This will alternate between the two clients\n    strategy [CustomGPT5Mini, CustomHaiku]\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/fallback\nclient<llm> OpenaiFallback {\n  provider fallback\n  options {\n    // This will try the clients in order until one succeeds\n    strategy [CustomGPT5Mini, CustomGPT5]\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/retry\nretry_policy Constant {\n  max_retries 3\n  strategy {\n    type constant_delay\n    delay_ms 200\n  }\n}\n\nretry_policy Exponential {\n  max_retries 2\n  strategy {\n    type exponential_backoff\n    delay_ms 300\n    multiplier 1.5\n    max_delay_ms 10000\n  }\n}\n",
    "generators.baml": "// This helps use auto generate libraries you can use in the language of\n// your choice. You can have multiple generators if you use multiple languages.\n// Just ensure that the output_dir is different for each generator.\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"python/pydantic\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../\"\n\n    // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\n    // The BAML VSCode extension version should also match this version.\n    version \"0.216.0\"\n\n    // Valid values: \"sync\", \"async\"\n    // This controls what `b.FunctionName()` will be (sync or async).\n    default_client_mode sync\n}\n",
    "link_classifier.baml": "// Link Classification for Sagebase\n// リンク分類用のBAML定義\n\n// ========================================\n// Class Definitions (Pydanticモデルに対応)\n// ========================================\n\n// LinkClassification - 個別リンクの分類結果\nclass LinkClassification {\n    url string @description(\"The URL being classified\")\n    link_type string @description(\"Type of link: prefecture_list, city_list, member_list, member_profile, other\")\n    confidence float @description(\"Confidence score (0.0-1.0)\")\n    reason string @description(\"Reason for classification\")\n}\n\n// ========================================\n// Function Definitions\n// ========================================\n\n// Function: リンクを分類\nfunction ClassifyLinks(\n    links: string,\n    party_name: string,\n    context: string\n) -> LinkClassification[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のリンクを分類してください。\n\n        リンク情報:\n        {{ links }}\n\n        政党名: {{ party_name }}\n        コンテキスト: {{ context }}\n\n        タスク:\n        各リンクを以下のタイプに分類してください:\n        - prefecture_list: 都道府県別リスト（例: 「北海道」「東京都」などのリンク）\n        - city_list: 市区町村別リスト（例: 「札幌市」「渋谷区」などのリンク）\n        - member_list: 議員一覧ページ（例: 「議員一覧」「メンバー紹介」などのリンク）\n        - member_profile: 議員個人ページ（例: 個別の議員名のリンク）\n        - other: その他のリンク\n\n        指示:\n        1. 各リンクのURL、テキスト、タイトルから適切なタイプを判定してください\n        2. URLは元のリンク情報から正確に抽出してください（改変しない）\n        3. confidenceは分類の確信度を0.0-1.0で表してください\n        4. reasonには判定理由を簡潔に説明してください（日本語で）\n\n        注意:\n        - URLは必ずリンク情報に含まれているものをそのまま使用してください\n        - リンクのテキストやタイトルが分類の重要な手がかりになります\n        - 政党名やコンテキストも考慮して分類してください\n\n        出力形式（JSON配列）:\n        [\n          {\n            \"url\": \"https://example.com/link1\",\n            \"link_type\": \"member_list\",\n            \"confidence\": 0.95,\n            \"reason\": \"「議員一覧」というテキストから議員リストページと判断\"\n          },\n          {\n            \"url\": \"https://example.com/link2\",\n            \"link_type\": \"prefecture_list\",\n            \"confidence\": 0.88,\n            \"reason\": \"「北海道」というテキストから都道府県リストと判断\"\n          }\n        ]\n    \"#\n}\n",
    "member_extraction.baml": "// Conference Member Extraction for Sagebase\n// 会議体メンバー抽出用のBAML定義\n\n// 抽出されたメンバー情報の型定義\nclass ExtractedMember {\n    name string @description(\"議員名（フルネーム）\")\n    role string? @description(\"役職（議長、副議長、委員長、委員など）\")\n    party_name string? @description(\"所属政党名\")\n    additional_info string? @description(\"その他の情報\")\n}\n\n// メンバー抽出関数\nfunction ExtractMembers(\n    html: string,\n    conference_name: string\n) -> ExtractedMember[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のHTMLから{{ conference_name }}の議員メンバー情報を抽出してください。\n\n        重要: このページに複数の委員会や議会の情報が含まれている場合、\n        必ず「{{ conference_name }}」に所属する議員のみを抽出してください。\n        他の委員会や議会のメンバーは抽出しないでください。\n\n        HTMLコンテンツ:\n        {{ html }}\n\n        抽出する情報:\n        1. 議員名（フルネーム）\n        2. 役職（議長、副議長、委員長、副委員長、委員など）\n        3. 所属政党名（わかる場合）\n        4. その他の重要な情報\n\n        注意事項:\n        - 議員名は姓名を正確に抽出してください\n        - 敬称（議員、氏、さん、様、先生など）は除外してください\n        - 役職がない場合は「委員」としてください\n        - 所属政党が明記されていない場合はnullとしてください\n        - 複数の役職がある場合は主要な役職を選択してください\n        - 必ず指定された「{{ conference_name }}」に関連する議員のみを抽出し、\n          他の委員会や議会のメンバーは含めないでください\n\n        **重要: 必ず以下の英語フィールド名でJSONを返してください:**\n        - name: 議員名\n        - role: 役職\n        - party_name: 所属政党名\n        - additional_info: その他の情報\n    \"#\n}\n",
    "minutes_divider.baml": "// Minutes Divider for Sagebase\n// 議事録分割処理用のBAML定義\n\n// ========================================\n// Class Definitions (Pydanticモデルに対応)\n// ========================================\n\n// 1. SectionInfo - 分割されたセクションの情報\nclass SectionInfo {\n    chapter_number int @description(\"分割した文字列を前から順に割り振った番号\")\n    keyword string @description(\"分割した文字列の先頭30文字をそのまま抽出した文字列\")\n}\n\n// 2. SectionString - 分割されたセクションの文字列\nclass SectionString {\n    chapter_number int @description(\"分割した文字列を前から順に割り振った番号\")\n    sub_chapter_number int @description(\"再分割した場合の文字列番号\")\n    section_string string @description(\"分割した文字列\")\n}\n\n// 3. RedividedSectionInfo - 再分割されたセクションの情報\nclass RedividedSectionInfo {\n    chapter_number int @description(\"再分割前の順番を表す番号\")\n    sub_chapter_number int @description(\"再分割した中での順番を表す番号\")\n    keyword string @description(\"分割した文字列の先頭30文字をそのまま抽出した文字列\")\n}\n\n// 4. SpeakerAndSpeechContent - 発言者と発言内容\nclass SpeakerAndSpeechContent {\n    speaker string @description(\"発言者\")\n    speech_content string @description(\"発言内容\")\n    chapter_number int @description(\"分割した文字列を前から順に割り振った番号\")\n    sub_chapter_number int @description(\"再分割した場合の文字列番号\")\n    speech_order int @description(\"発言順\")\n}\n\n// 5. MinutesBoundary - 議事録の境界検出結果\nclass MinutesBoundary {\n    boundary_found bool @description(\"境界が見つかったかどうか\")\n    boundary_text string? @description(\"境界前後の文字列（｜境界｜でマーク）\")\n    boundary_type string @description(\"境界の種類: separator_line, speech_start, time_marker, none\")\n    confidence float @description(\"境界検出の信頼度（0.0-1.0）\")\n    reason string @description(\"境界判定の理由\")\n}\n\n// 6. AttendeesMapping - 出席者の役職と名前のマッピング\nclass AttendeesMapping {\n    attendees_mapping map<string, string?>? @description(\"役職から人名へのマッピング（使用しない場合はnull）\")\n    regular_attendees string[] @description(\"出席者の人名リスト\")\n    confidence float @description(\"抽出の信頼度（0.0-1.0）\")\n}\n\n// ========================================\n// Function Definitions\n// ========================================\n\n// Function 1: 議事録を章に分割してキーワードリストを返す\nfunction DivideMinutesToKeywords(minutes: string) -> SectionInfo[] {\n    client Gemini2Flash\n    prompt #\"\n        以下の議事録を意味のあるセクション（章）に分割して、各セクションの先頭キーワードを抽出してください。\n\n        議事録:\n        {{ minutes }}\n\n        指示:\n        1. 議事録を意味のある単位で分割してください（発言者の変更、議題の変更など）\n        2. 各セクションの先頭30文字をキーワードとして抽出してください\n        3. chapter_numberは1から順番に割り振ってください\n        4. キーワードは元の文字列から正確に抽出してください（改変しない）\n        5. できるだけ多くのセクションに分割してください（目安: 5-30セクション）\n\n        注意:\n        - キーワードは議事録内に実際に存在する文字列である必要があります\n        - キーワードは先頭から正確に30文字抽出してください（30文字未満の場合は全文）\n\n        出力形式（JSON配列）:\n        [\n          {\n            \"chapter_number\": 1,\n            \"keyword\": \"先頭30文字のキーワード\"\n          },\n          {\n            \"chapter_number\": 2,\n            \"keyword\": \"次のセクションの先頭30文字\"\n          }\n        ]\n\n        重要: \"keyword\"フィールドを使用してください（\"keywords\"ではありません）\n    \"#\n}\n\n// Function 2: 出席者情報と発言部分の境界を検出\nfunction DetectBoundary(minutes_text: string) -> MinutesBoundary {\n    client Gemini2Flash\n    prompt #\"\n        以下の議事録テキストから、出席者情報と発言部分の境界を検出してください。\n\n        議事録テキスト:\n        {{ minutes_text }}\n\n        指示:\n        1. 出席者リストや役員名簿と、実際の発言内容の境界を見つけてください\n        2. 境界が見つかった場合、boundary_foundをtrueにしてください\n        3. boundary_textには境界前後のテキストを「｜境界｜」でマークして返してください\n           - 境界の前20文字 + ｜境界｜ + 境界の後20文字 の形式\n        4. boundary_typeは以下のいずれか:\n           - separator_line: 区切り線（---、===など）で区切られている\n           - speech_start: 発言開始パターン（○、◆など）で区切られている\n           - time_marker: 時刻表記で区切られている\n           - none: 境界が見つからない\n        5. confidenceは境界検出の確信度（0.0-1.0）\n        6. reasonには判定理由を簡潔に説明してください\n\n        境界が見つからない場合:\n        - boundary_found=false\n        - boundary_text=null\n        - boundary_type=\"none\"\n        - confidence=0.0\n    \"#\n}\n\n// Function 3: 出席者情報を抽出\nfunction ExtractAttendees(attendees_text: string) -> AttendeesMapping {\n    client Gemini2Flash\n    prompt #\"\n        以下の出席者情報テキストから、役職と人名のマッピングを抽出してください。\n\n        出席者情報:\n        {{ attendees_text }}\n\n        指示:\n        1. 役職と人名の対応関係を抽出してください（例: \"議長\" -> \"山田太郎\"）\n        2. regular_attendeesには全ての出席者の名前をリストで返してください\n        3. 敬称（議員、氏、さん、様、先生など）は除外してください\n        4. confidenceは抽出の確信度（0.0-1.0）\n        5. attendees_mappingは役職が明確な場合のみ設定し、不明な場合はnullとしてください\n\n        注意:\n        - 人名は姓名を正確に抽出してください\n        - 同じ人物が複数回出現する場合は重複を除いてください\n    \"#\n}\n\n// Function 4: 発言者と発言内容に分割\nfunction DivideSpeech(section_string: string) -> SpeakerAndSpeechContent[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のセクションテキストから、発言者と発言内容を抽出してください。\n\n        セクション内容:\n        {{ section_string }}\n\n        指示:\n        1. 各発言を発言者と発言内容に分割してください\n        2. 発言者名は正確に抽出してください（敬称を除く）\n        3. speech_orderは1から順番に割り振ってください\n        4. chapter_numberとsub_chapter_numberは1に設定してください（後で更新されます）\n        5. 発言内容は発言者の発言部分のみを含めてください\n\n        国会議事録の一般的なフォーマット:\n        - ○議長（名前）発言内容\n        - ◆議員（名前）発言内容\n        - ○委員長（名前）発言内容\n\n        注意:\n        - 発言者が明示されていない場合でも、文脈から推測して抽出してください\n        - 発言内容は元のテキストから正確に抽出してください\n\n        出力形式（JSON配列）:\n        [\n          {\n            \"speaker\": \"発言者名（敬称なし）\",\n            \"speech_content\": \"発言内容\",\n            \"chapter_number\": 1,\n            \"sub_chapter_number\": 1,\n            \"speech_order\": 1\n          },\n          {\n            \"speaker\": \"次の発言者名\",\n            \"speech_content\": \"次の発言内容\",\n            \"chapter_number\": 1,\n            \"sub_chapter_number\": 1,\n            \"speech_order\": 2\n          }\n        ]\n\n        重要: \"speech_content\"フィールドを使用してください（\"utterance\", \"speech\"ではありません）\n    \"#\n}\n\n// Function 5: 長いセクションを再分割\nfunction RedivideSection(section_text: string, divide_counter: int, original_index: int) -> SectionInfo[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のセクションを{{ divide_counter }}個に再分割してください。\n\n        元のインデックス: {{ original_index }}\n\n        セクション内容:\n        {{ section_text }}\n\n        指示:\n        1. セクションを{{ divide_counter }}個の意味のある単位に分割してください\n        2. 各セクションの先頭30文字をキーワードとして抽出してください\n        3. chapter_numberは1から順番に割り振ってください\n        4. キーワードは元の文字列から正確に抽出してください（改変しない）\n\n        注意:\n        - 意味のある区切りで分割してください（発言者の変更、議題の変更など）\n        - キーワードは議事録内に実際に存在する文字列である必要があります\n    \"#\n}\n",
    "page_classifier.baml": "// Page Classification for Sagebase\n// ページ分類用のBAML定義\n\n// ========================================\n// Class Definitions (Pydanticモデルに対応)\n// ========================================\n\n// PageClassification - ページタイプの分類結果\nclass PageClassification {\n    page_type string @description(\"Type of page: index_page, member_list_page, other\")\n    confidence float @description(\"Confidence score (0.0-1.0)\")\n    reason string @description(\"Reason for classification\")\n    has_child_links bool @description(\"Whether the page has child links\")\n    has_member_info bool @description(\"Whether the page has member information\")\n}\n\n// ========================================\n// Function Definitions\n// ========================================\n\n// Function: ページを分類\nfunction ClassifyPage(\n    html_excerpt: string,\n    current_url: string,\n    party_name: string\n) -> PageClassification {\n    client Gemini2Flash\n    prompt #\"\n        以下のWebページを分類してください。\n\n        URL: {{ current_url }}\n        政党名: {{ party_name }}\n\n        HTMLの一部（抜粋）:\n        {{ html_excerpt }}\n\n        タスク:\n        このページを以下のタイプに分類してください:\n        - index_page: インデックスページ（他のページへのリンク集、ナビゲーションページ）\n        - member_list_page: 議員一覧ページ（議員の情報が掲載されているページ）\n        - other: その他のページ\n\n        指示:\n        1. HTMLの内容から適切なページタイプを判定してください\n        2. has_child_links: このページに子ページへのリンクがあるかを判定（true/false）\n        3. has_member_info: このページに議員情報が含まれているかを判定（true/false）\n        4. confidence: 分類の確信度を0.0-1.0で表してください\n        5. reason: 判定理由を簡潔に説明してください（日本語で）\n\n        判定のポイント:\n        - インデックスページ: 「都道府県一覧」「支部一覧」「地域別」などのナビゲーションリンクが多い\n        - 議員一覧ページ: 議員名、役職、連絡先、プロフィールなどの情報が複数含まれている\n        - その他: 上記に該当しない一般的なページ\n\n        注意:\n        - URLやHTMLの構造から総合的に判断してください\n        - 政党名も判定の参考にしてください\n        - HTMLは抜粋なので、完全な情報がない場合もあります\n\n        出力形式（JSON）:\n        {\n          \"page_type\": \"index_page\",\n          \"confidence\": 0.92,\n          \"reason\": \"「都道府県別」「支部一覧」などのナビゲーションリンクが多数含まれているため、インデックスページと判断\",\n          \"has_child_links\": true,\n          \"has_member_info\": false\n        }\n    \"#\n}\n",
    "parliamentary_group_member_extractor.baml": "// Parliamentary Group Member Extraction for Sagebase\n// 議員団メンバー抽出用のBAML定義\n\n// 抽出された議員団メンバー情報の型定義\nclass ParliamentaryGroupMember {\n    name string @description(\"議員名（フルネーム）\")\n    role string? @description(\"役職（団長、幹事長、政調会長など）\")\n    party_name string? @description(\"所属政党名\")\n    district string? @description(\"選挙区\")\n    additional_info string? @description(\"その他の情報\")\n}\n\n// 議員団メンバー抽出関数\nfunction ExtractParliamentaryGroupMembers(\n    html: string,\n    text_content: string\n) -> ParliamentaryGroupMember[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のWebページから議員団に所属する議員の情報を抽出してください。\n\n        各議員について以下の情報を抽出:\n        1. 議員の氏名（必須、フルネーム）\n        2. 議員団内での役職（団長、幹事長、政調会長など）\n        3. 所属政党名（議員団名とは異なる場合のみ）\n        4. 選挙区\n        5. その他の重要な情報\n\n        注意事項:\n        - 議員団（会派）のメンバー一覧を抽出してください\n        - 役職者だけでなく、一般のメンバーも含めて全員を抽出してください\n        - 名前の表記は元のページの表記を維持してください\n        - 敬称（議員、氏、さん、様、先生など）は除外してください\n        - 議員団名と政党名は異なる場合があります（例：「○○会派」と「△△党」）\n        - 役職がない場合はnullとしてください\n        - 所属政党が明記されていない場合はnullとしてください\n\n        **重要: 必ず以下の英語フィールド名でJSONを返してください:**\n        - name: 議員名\n        - role: 役職\n        - party_name: 所属政党名\n        - district: 選挙区\n        - additional_info: その他の情報\n\n        テキストコンテンツ:\n        {{ text_content }}\n\n        HTMLコンテンツ（構造の参考用）:\n        {{ html }}\n\n        上記の情報から、議員団メンバー全員の情報を抽出してください。\n    \"#\n}\n",
    "politician_matching.baml": "// Politician Matching for Sagebase\n// 政治家マッチング用のBAML定義\n\n// ========================================\n// Class Definitions (Pydanticモデルに対応)\n// ========================================\n\n// PoliticianMatch - 政治家マッチング結果\nclass PoliticianMatch {\n    matched bool @description(\"マッチングが成功したか\")\n    politician_id int? @description(\"マッチした政治家のID（マッチしない場合はnull）\")\n    politician_name string? @description(\"マッチした政治家の名前（マッチしない場合はnull）\")\n    political_party_name string? @description(\"所属政党名（マッチしない場合はnull）\")\n    confidence float @description(\"マッチングの信頼度（0.0-1.0）\")\n    reason string @description(\"マッチング判定の理由\")\n}\n\n// ========================================\n// Function Definitions\n// ========================================\n\n// Function: 政治家マッチング\nfunction MatchPolitician(\n    speaker_name: string,\n    speaker_type: string,\n    speaker_party: string,\n    available_politicians: string\n) -> PoliticianMatch {\n    client Gemini2Flash\n    prompt #\"\n        あなたは発言者と政治家のマッチング専門家です。\n        発言者情報と既存の政治家リストから最も適切なマッチを見つけてください。\n\n        # 発言者情報\n        名前: {{ speaker_name }}\n        種別: {{ speaker_type }}\n        所属政党: {{ speaker_party }}\n\n        # 候補となる政治家リスト\n        {{ available_politicians }}\n\n        # マッチング基準\n        1. 氏名の完全一致を最優先\n        2. 所属政党が一致する場合は信頼度を上げる\n        3. 表記ゆれを考慮（例: \"斉藤\" と \"齊藤\"）\n        4. 同姓同名の場合は政党や役職で判断\n        5. 部分一致や音韻的類似性\n\n        # 信頼度の基準\n        - 0.9以上: 氏名と政党が完全一致\n        - 0.7-0.9: 氏名は一致するが政党が不明または部分一致\n        - 0.5-0.7: 氏名に表記ゆれがあるが政党は一致\n        - 0.5未満: マッチング不可（matched: false）\n\n        # 出力要件\n        - 確実性が低い場合は matched: false を返す\n        - confidence は 0.7 以上の場合のみマッチとして扱う\n        - マッチしない場合は politician_id, politician_name, political_party_name を null に設定\n\n        # 重要\n        - 信頼度が0.7未満の場合は、必ず matched: false を返してください。\n        - **必ず**指定された形式のJSONで出力してください。自然言語での説明は禁止です。\n        - 役職名のみの入力（例：「委員長」「副議長」「事務局長」）は個人を特定できないため、\n          matched: false, confidence: 0.0, reason: \"役職名のみのため個人を特定できません\" を返してください。\n        - マッチする政治家がいない場合も、必ず構造化された形式で出力してください。\n\n        # 出力形式（この形式に厳密に従ってください）\n        マッチ成功の場合:\n        {\n          \"matched\": true,\n          \"politician_id\": <政治家ID>,\n          \"politician_name\": \"<政治家名>\",\n          \"political_party_name\": \"<政党名>\",\n          \"confidence\": <0.0-1.0>,\n          \"reason\": \"<マッチング判定の理由を必ず記述>\"\n        }\n\n        マッチ失敗の場合:\n        {\n          \"matched\": false,\n          \"politician_id\": null,\n          \"politician_name\": null,\n          \"political_party_name\": null,\n          \"confidence\": <0.0-1.0>,\n          \"reason\": \"<マッチしない理由を必ず記述>\"\n        }\n\n        {{ ctx.output_format }}\n    \"#\n}\n",
    "resume.baml": "// Defining a data model.\nclass Resume {\n  name string\n  email string\n  experience string[]\n  skills string[]\n}\n\n// Create a function to extract the resume from a string.\nfunction ExtractResume(resume: string) -> Resume {\n  // Specify a client as provider/model-name\n  // You can also use custom LLM params with a custom client name from clients.baml like \"client CustomGPT5\" or \"client CustomSonnet4\"\n  client \"openai-responses/gpt-5-mini\" // Set OPENAI_API_KEY to use this client.\n  prompt #\"\n    Extract from this content:\n    {{ resume }}\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n\n\n// Test the function with a sample resume. Open the VSCode playground to run this.\ntest vaibhav_resume {\n  functions [ExtractResume]\n  args {\n    resume #\"\n      Vaibhav Gupta\n      vbv@boundaryml.com\n\n      Experience:\n      - Founder at BoundaryML\n      - CV Engineer at Google\n      - CV Engineer at Microsoft\n\n      Skills:\n      - Rust\n      - C++\n    \"#\n  }\n}\n",
    "speaker_matching.baml": "// Speaker Matching for Sagebase\n// 話者マッチング用のBAML定義\n\n// ========================================\n// Class Definitions (Pydanticモデルに対応)\n// ========================================\n\n// SpeakerMatch - 話者マッチング結果\nclass SpeakerMatch {\n    matched bool @description(\"マッチングが成功したか\")\n    speaker_id int? @description(\"マッチした発言者のID（マッチしない場合はnull）\")\n    speaker_name string? @description(\"マッチした発言者の名前（マッチしない場合はnull）\")\n    confidence float @description(\"マッチングの信頼度（0.0-1.0）\")\n    reason string @description(\"マッチング判定の理由\")\n}\n\n// ========================================\n// Function Definitions\n// ========================================\n\n// Function: 話者マッチング\nfunction MatchSpeaker(\n    speaker_name: string,\n    available_speakers: string\n) -> SpeakerMatch {\n    client Gemini2Flash\n    prompt #\"\n        あなたは議事録の発言者名マッチング専門家です。\n        議事録から抽出された発言者名と、既存の発言者リストから最も適切なマッチを見つけてください。\n\n        # 抽出された発言者名\n        {{ speaker_name }}\n\n        # 既存の発言者リスト\n        {{ available_speakers }}\n\n        # マッチング基準\n        1. 完全一致を最優先\n        2. 括弧内の名前との一致（例: \"委員長(平山たかお)\" → \"平山たかお\"）\n        3. 記号除去後の一致（例: \"◆委員(下村あきら)\" → \"委員(下村あきら)\"）\n        4. 部分一致や音韻的類似性\n        5. 漢字の異なる読みや表記ゆれ\n        6. 会議体所属情報（★マーク）を重視（同じ会議体のメンバーを優先）\n\n        # 出力要件\n        - 確実性が低い場合は matched: false を返す\n        - confidence は 0.8 以上の場合のみマッチとして扱う\n        - 複数の候補がある場合は最も確からしいものを選ぶ\n        - 会議体所属メンバー（★マーク付き）は信頼度を+0.1加算\n        - マッチしない場合は speaker_id と speaker_name を null に設定\n\n        # 重要\n        信頼度が0.8未満の場合は、必ず matched: false を返してください。\n    \"#\n}\n",
    "speaker_matching_tools.baml": "// Speaker Matching Tools - BAML Definitions\n// LangGraph ReActエージェント用のツール定義\n\n// ===================================================================\n// judge_confidence: マッチング候補の確信度を総合判定\n// ===================================================================\n\nfunction JudgeMatchingConfidence(\n  speaker_name: string,\n  candidate_json: string,\n  additional_info_json: string?\n) -> ConfidenceJudgement {\n  client Gemini2Flash\n  prompt #\"\n    あなたは発言者と政治家の名寄せを専門とするエキスパートです。\n    発言者と政治家候補のマッチングの確信度を総合的に判定してください。\n\n    ## 入力情報\n\n    **発言者名**: {{ speaker_name }}\n\n    **候補政治家** (JSON):\n    {{ candidate_json }}\n\n    {% if additional_info_json %}\n    **追加情報** (JSON):\n    {{ additional_info_json }}\n    {% endif %}\n\n    ## 判定基準\n\n    以下の要素を総合的に評価してください：\n\n    1. **名前の一致度** (重要度: 最高)\n       - 完全一致（EXACT）: 非常に高い確信度\n       - 部分一致（PARTIAL）: 高い確信度\n       - 類似（FUZZY）: 中程度の確信度\n\n    2. **所属情報の一致** (重要度: 高)\n       - 会議体所属（is_affiliated: true）: 確信度を大きく向上\n       - 所属履歴（affiliation）あり: 確信度を向上\n\n    3. **政党情報の一致** (重要度: 中)\n       - 政党情報が一致: 確信度を向上\n\n    4. **文脈的整合性** (重要度: 中)\n       - 名前の意味的類似性\n       - 活動時期の整合性\n\n    ## 出力要件\n\n    **必須フィールド（すべて出力してください）:**\n\n    1. **confidence**: 0.0〜1.0の数値\n       - 例: 0.95\n\n    2. **confidence_level**: 確信度レベル（必ず以下のいずれか）\n       - \"HIGH\": 確信度0.9以上\n       - \"MEDIUM\": 確信度0.7〜0.9\n       - \"LOW\": 確信度0.7未満\n\n    3. **should_match**: マッチ推奨（boolean）\n       - true: 確信度0.8以上\n       - false: 確信度0.8未満\n\n    4. **reason**: 判定理由（日本語で明確に）\n\n    5. **contributing_factors**: 確信度に影響した要素（配列）\n       各要素には以下を含める:\n       - factor: 要素名（例: \"base_score\", \"affiliation\", \"party\"）\n       - impact: 影響度（-1.0〜1.0の数値）\n       - description: 日本語の説明\n\n    6. **recommendation**: 推奨アクション（日本語で）\n\n    **重要**: 上記のすべてのフィールドを必ず出力してください。\n    特に `confidence_level` フィールドは必須です。\n  \"#\n}\n\n// ===================================================================\n// Data Classes\n// ===================================================================\n\nclass ConfidenceJudgement {\n  confidence float @description(\"確信度 (0.0-1.0)\")\n  confidence_level string @description(\"確信度レベル (HIGH/MEDIUM/LOW)\")\n  should_match bool @description(\"マッチすべきかどうか (confidence >= 0.8)\")\n  reason string @description(\"判定理由の説明\")\n  contributing_factors ContributingFactor[] @description(\"確信度に寄与した要素\")\n  recommendation string @description(\"推奨アクション\")\n}\n\nclass ContributingFactor {\n  factor string @description(\"要素名 (例: base_score, affiliation, party)\")\n  impact float @description(\"スコアへの影響 (-1.0 to 1.0)\")\n  description string @description(\"説明\")\n}\n",
}

def get_baml_files():
    return _file_map
