# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "clients.baml": "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\n\n// Using the new OpenAI Responses API for enhanced formatting\nclient<llm> CustomGPT5 {\n  provider openai-responses\n  options {\n    model \"gpt-5\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\nclient<llm> CustomGPT5Mini {\n  provider openai-responses\n  retry_policy Exponential\n  options {\n    model \"gpt-5-mini\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\n// Openai with chat completion\nclient<llm> CustomGPT5Chat {\n  provider openai\n  options {\n    model \"gpt-5\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\n// Latest Anthropic Claude 4 models\nclient<llm> CustomOpus4 {\n  provider anthropic\n  options {\n    model \"claude-opus-4-1-20250805\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\nclient<llm> CustomSonnet4 {\n  provider anthropic\n  options {\n    model \"claude-sonnet-4-20250514\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\nclient<llm> CustomHaiku {\n  provider anthropic\n  retry_policy Constant\n  options {\n    model \"claude-3-5-haiku-20241022\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\n// Google AI client for Sagebase (gemini-2.5-flash)\n// BAML automatically handles structured output based on function return types\nclient<llm> Gemini2Flash {\n  provider google-ai\n  retry_policy Exponential\n  options {\n    model \"gemini-2.5-flash\"\n    api_key env.GOOGLE_API_KEY\n  }\n}\n\n// Example AWS Bedrock client (uncomment to use)\n// client<llm> CustomBedrock {\n//   provider aws-bedrock\n//   options {\n//     model \"anthropic.claude-sonnet-4-20250514-v1:0\"\n//     region \"us-east-1\"\n//     // AWS credentials are auto-detected from env vars\n//   }\n// }\n\n// Example Azure OpenAI client (uncomment to use)\n// client<llm> CustomAzure {\n//   provider azure-openai\n//   options {\n//     model \"gpt-5\"\n//     api_key env.AZURE_OPENAI_API_KEY\n//     base_url \"https://MY_RESOURCE_NAME.openai.azure.com/openai/deployments/MY_DEPLOYMENT_ID\"\n//     api_version \"2024-10-01-preview\"\n//   }\n// }\n\n// Example Vertex AI client (uncomment to use)\n// client<llm> CustomVertex {\n//   provider vertex-ai\n//   options {\n//     model \"gemini-2.5-pro\"\n//     location \"us-central1\"\n//     // Uses Google Cloud Application Default Credentials\n//   }\n// }\n\n// Example Ollama client for local models (uncomment to use)\n// client<llm> CustomOllama {\n//   provider openai-generic\n//   options {\n//     base_url \"http://localhost:11434/v1\"\n//     model \"llama4\"\n//     default_role \"user\" // Most local models prefer the user role\n//     // No API key needed for local Ollama\n//   }\n// }\n\n// https://docs.boundaryml.com/docs/snippets/clients/round-robin\nclient<llm> CustomFast {\n  provider round-robin\n  options {\n    // This will alternate between the two clients\n    strategy [CustomGPT5Mini, CustomHaiku]\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/fallback\nclient<llm> OpenaiFallback {\n  provider fallback\n  options {\n    // This will try the clients in order until one succeeds\n    strategy [CustomGPT5Mini, CustomGPT5]\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/retry\nretry_policy Constant {\n  max_retries 3\n  strategy {\n    type constant_delay\n    delay_ms 200\n  }\n}\n\nretry_policy Exponential {\n  max_retries 2\n  strategy {\n    type exponential_backoff\n    delay_ms 300\n    multiplier 1.5\n    max_delay_ms 10000\n  }\n}\n",
    "generators.baml": "// This helps use auto generate libraries you can use in the language of\n// your choice. You can have multiple generators if you use multiple languages.\n// Just ensure that the output_dir is different for each generator.\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"python/pydantic\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../\"\n\n    // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\n    // The BAML VSCode extension version should also match this version.\n    version \"0.217.0\"\n\n    // Valid values: \"sync\", \"async\"\n    // This controls what `b.FunctionName()` will be (sync or async).\n    default_client_mode sync\n}\n",
    "link_classifier.baml": "// Link Classification for Sagebase\n// リンク分類用のBAML定義\n\n// ========================================\n// Class Definitions (Pydanticモデルに対応)\n// ========================================\n\n// LinkClassification - 個別リンクの分類結果\nclass LinkClassification {\n    url string @description(\"The URL being classified\")\n    link_type string @description(\"Type of link: prefecture_list, city_list, member_list, member_profile, other\")\n    confidence float @description(\"Confidence score (0.0-1.0)\")\n    reason string @description(\"Reason for classification\")\n}\n\n// ========================================\n// Function Definitions\n// ========================================\n\n// Function: リンクを分類\nfunction ClassifyLinks(\n    links: string,\n    party_name: string,\n    context: string\n) -> LinkClassification[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のリンクを分類してください。\n\n        リンク情報:\n        {{ links }}\n\n        政党名: {{ party_name }}\n        コンテキスト: {{ context }}\n\n        タスク:\n        各リンクを以下のタイプに分類してください:\n        - prefecture_list: 都道府県別リスト（例: 「北海道」「東京都」などのリンク）\n        - city_list: 市区町村別リスト（例: 「札幌市」「渋谷区」などのリンク）\n        - member_list: 議員一覧ページ（例: 「議員一覧」「メンバー紹介」などのリンク）\n        - member_profile: 議員個人ページ（例: 個別の議員名のリンク）\n        - other: その他のリンク\n\n        指示:\n        1. 各リンクのURL、テキスト、タイトルから適切なタイプを判定してください\n        2. URLは元のリンク情報から正確に抽出してください（改変しない）\n        3. confidenceは分類の確信度を0.0-1.0で表してください\n        4. reasonには判定理由を簡潔に説明してください（日本語で）\n\n        注意:\n        - URLは必ずリンク情報に含まれているものをそのまま使用してください\n        - リンクのテキストやタイトルが分類の重要な手がかりになります\n        - 政党名やコンテキストも考慮して分類してください\n\n        出力形式（JSON配列）:\n        [\n          {\n            \"url\": \"https://example.com/link1\",\n            \"link_type\": \"member_list\",\n            \"confidence\": 0.95,\n            \"reason\": \"「議員一覧」というテキストから議員リストページと判断\"\n          },\n          {\n            \"url\": \"https://example.com/link2\",\n            \"link_type\": \"prefecture_list\",\n            \"confidence\": 0.88,\n            \"reason\": \"「北海道」というテキストから都道府県リストと判断\"\n          }\n        ]\n    \"#\n}\n",
    "member_extraction.baml": "// Conference Member Extraction for Sagebase\n// 会議体メンバー抽出用のBAML定義\n\n// 抽出されたメンバー情報の型定義\nclass ExtractedMember {\n    name string @description(\"議員名（フルネーム）\")\n    role string? @description(\"役職（議長、副議長、委員長、委員など）\")\n    party_name string? @description(\"所属政党名\")\n    additional_info string? @description(\"その他の情報\")\n}\n\n// メンバー抽出関数\nfunction ExtractMembers(\n    html: string,\n    conference_name: string\n) -> ExtractedMember[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のHTMLから{{ conference_name }}の議員メンバー情報を抽出してください。\n\n        重要: このページに複数の委員会や議会の情報が含まれている場合、\n        必ず「{{ conference_name }}」に所属する議員のみを抽出してください。\n        他の委員会や議会のメンバーは抽出しないでください。\n\n        HTMLコンテンツ:\n        {{ html }}\n\n        抽出する情報:\n        1. 議員名（フルネーム）\n        2. 役職（議長、副議長、委員長、副委員長、委員など）\n        3. 所属政党名（わかる場合）\n        4. その他の重要な情報\n\n        注意事項:\n        - 議員名は姓名を正確に抽出してください\n        - 敬称（議員、氏、さん、様、先生など）は除外してください\n        - 役職がない場合は「委員」としてください\n        - 所属政党が明記されていない場合はnullとしてください\n        - 複数の役職がある場合は主要な役職を選択してください\n        - 必ず指定された「{{ conference_name }}」に関連する議員のみを抽出し、\n          他の委員会や議会のメンバーは含めないでください\n\n        **重要: 必ず以下の英語フィールド名でJSONを返してください:**\n        - name: 議員名\n        - role: 役職\n        - party_name: 所属政党名\n        - additional_info: その他の情報\n    \"#\n}\n",
    "minutes_divider.baml": "// Minutes Divider for Sagebase\n// 議事録分割処理用のBAML定義\n\n// ========================================\n// Class Definitions (Pydanticモデルに対応)\n// ========================================\n\n// 1. SectionInfo - 分割されたセクションの情報\nclass SectionInfo {\n    chapter_number int @description(\"分割した文字列を前から順に割り振った番号\")\n    keyword string @description(\"分割した文字列の先頭30文字をそのまま抽出した文字列\")\n}\n\n// 2. SectionString - 分割されたセクションの文字列\nclass SectionString {\n    chapter_number int @description(\"分割した文字列を前から順に割り振った番号\")\n    sub_chapter_number int @description(\"再分割した場合の文字列番号\")\n    section_string string @description(\"分割した文字列\")\n}\n\n// 3. RedividedSectionInfo - 再分割されたセクションの情報\nclass RedividedSectionInfo {\n    chapter_number int @description(\"再分割前の順番を表す番号\")\n    sub_chapter_number int @description(\"再分割した中での順番を表す番号\")\n    keyword string @description(\"分割した文字列の先頭30文字をそのまま抽出した文字列\")\n}\n\n// 4. SpeakerAndSpeechContent - 発言者と発言内容\nclass SpeakerAndSpeechContent {\n    speaker string @description(\"発言者\")\n    speech_content string @description(\"発言内容\")\n    chapter_number int @description(\"分割した文字列を前から順に割り振った番号\")\n    sub_chapter_number int @description(\"再分割した場合の文字列番号\")\n    speech_order int @description(\"発言順\")\n}\n\n// 5. MinutesBoundary - 議事録の境界検出結果\nclass MinutesBoundary {\n    boundary_found bool @description(\"境界が見つかったかどうか\")\n    boundary_text string? @description(\"境界前後の文字列（｜境界｜でマーク）\")\n    boundary_type string @description(\"境界の種類: separator_line, speech_start, time_marker, none\")\n    confidence float @description(\"境界検出の信頼度（0.0-1.0）\")\n    reason string @description(\"境界判定の理由\")\n}\n\n// 6. AttendeesMapping - 出席者の役職と名前のマッピング\nclass AttendeesMapping {\n    attendees_mapping map<string, string?>? @description(\"役職から人名へのマッピング（使用しない場合はnull）\")\n    regular_attendees string[] @description(\"出席者の人名リスト\")\n    confidence float @description(\"抽出の信頼度（0.0-1.0）\")\n}\n\n// ========================================\n// Function Definitions\n// ========================================\n\n// Function 1: 議事録を章に分割してキーワードリストを返す\nfunction DivideMinutesToKeywords(minutes: string) -> SectionInfo[] {\n    client Gemini2Flash\n    prompt #\"\n        以下の議事録を意味のあるセクション（章）に分割して、各セクションの先頭キーワードを抽出してください。\n\n        議事録:\n        {{ minutes }}\n\n        指示:\n        1. 議事録を意味のある単位で分割してください（発言者の変更、議題の変更など）\n        2. 各セクションの先頭30文字をキーワードとして抽出してください\n        3. chapter_numberは1から順番に割り振ってください\n        4. キーワードは元の文字列から正確に抽出してください（改変しない）\n        5. できるだけ多くのセクションに分割してください（目安: 5-30セクション）\n\n        【重要】以下の視覚的な区切り線はセクションの境界として扱わないでください:\n        - ～～～～～～（波線）\n        - ──────（ダッシュ）\n        - ━━━━━━（罫線）\n        - ========（イコール）\n        - --------（ハイフン）\n        これらは議事録のフォーマット上の装飾であり、発言の区切りではありません。\n        発言者の変更（○議長、◆議員、◎委員長など）や議題の変更を境界として使用してください。\n\n        注意:\n        - キーワードは議事録内に実際に存在する文字列である必要があります\n        - キーワードは先頭から正確に30文字抽出してください（30文字未満の場合は全文）\n        - 区切り線のみで構成されるセクションは作成しないでください\n\n        出力形式（JSON配列）:\n        [\n          {\n            \"chapter_number\": 1,\n            \"keyword\": \"先頭30文字のキーワード\"\n          },\n          {\n            \"chapter_number\": 2,\n            \"keyword\": \"次のセクションの先頭30文字\"\n          }\n        ]\n\n        重要: \"keyword\"フィールドを使用してください（\"keywords\"ではありません）\n    \"#\n}\n\n// Function 2: 出席者情報と発言部分の境界を検出\nfunction DetectBoundary(minutes_text: string) -> MinutesBoundary {\n    client Gemini2Flash\n    prompt #\"\n        以下の議事録テキストから、出席者情報と発言部分の境界を検出してください。\n\n        議事録テキスト:\n        {{ minutes_text }}\n\n        指示:\n        1. 出席者リストや役員名簿と、実際の発言内容の境界を見つけてください\n        2. 境界が見つかった場合、boundary_foundをtrueにしてください\n        3. boundary_textには境界前後のテキストを「｜境界｜」でマークして返してください\n           - 境界の前20文字 + ｜境界｜ + 境界の後20文字 の形式\n        4. boundary_typeは以下のいずれか:\n           - separator_line: 区切り線（---、===など）で区切られている\n           - speech_start: 発言開始パターン（○、◆など）で区切られている\n           - time_marker: 時刻表記で区切られている\n           - none: 境界が見つからない\n        5. confidenceは境界検出の確信度（0.0-1.0）\n        6. reasonには判定理由を簡潔に説明してください\n\n        境界が見つからない場合:\n        - boundary_found=false\n        - boundary_text=null\n        - boundary_type=\"none\"\n        - confidence=0.0\n    \"#\n}\n\n// Function 3: 出席者情報を抽出\nfunction ExtractAttendees(attendees_text: string) -> AttendeesMapping {\n    client Gemini2Flash\n    prompt #\"\n        以下の出席者情報テキストから、役職と人名のマッピングを抽出してください。\n\n        出席者情報:\n        {{ attendees_text }}\n\n        指示:\n        1. 役職と人名の対応関係を抽出してください（例: \"議長\" -> \"山田太郎\"）\n        2. regular_attendeesには全ての出席者の名前をリストで返してください\n        3. 敬称（議員、氏、さん、様、先生など）は除外してください\n        4. confidenceは抽出の確信度（0.0-1.0）\n        5. attendees_mappingは役職が明確な場合のみ設定し、不明な場合はnullとしてください\n\n        注意:\n        - 人名は姓名を正確に抽出してください\n        - 同じ人物が複数回出現する場合は重複を除いてください\n    \"#\n}\n\n// Function 4: 発言者と発言内容に分割\nfunction DivideSpeech(section_string: string) -> SpeakerAndSpeechContent[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のセクションテキストから、発言者と発言内容を抽出してください。\n\n        セクション内容:\n        {{ section_string }}\n\n        指示:\n        1. 各発言を発言者と発言内容に分割してください\n        2. 発言者名は正確に抽出してください（敬称を除く）\n        3. speech_orderは1から順番に割り振ってください\n        4. chapter_numberとsub_chapter_numberは1に設定してください（後で更新されます）\n        5. 発言内容は発言者の発言部分のみを含めてください\n\n        議事録の一般的なフォーマット:\n        - ○議長（名前）発言内容\n        - ◆議員（名前）発言内容\n        - ○委員長（名前）発言内容\n        - ◎市長（名前）発言内容\n        - ◎副市長（名前）発言内容\n        - ◎部長（名前）発言内容\n        ※ ○、◆、◎、●などの記号で発言者が示されます\n\n        【重要】以下は発言として抽出しないでください:\n        - 発言者を特定できないテキスト（「不明」として出力しないこと）\n        - 括弧で囲まれた文書要素: （イメージ）、（表）、（図）、（資料）、（請願文書表）など\n        - 議事進行の説明文やト書き\n        - 議題名や文書タイトルのみのセクション\n\n        【発言者として認められるもの】:\n        - 人名（姓名、または姓のみ）\n        - 役職名（議長、委員長、大臣など）\n        - 役職名（人名）の形式\n\n        注意:\n        - 発言者が明確に特定できる発言のみを抽出してください\n        - 発言内容は元のテキストから正確に抽出してください\n        - 発言者を特定できない場合は、その部分はスキップしてください\n\n        出力形式（JSON配列）:\n        [\n          {\n            \"speaker\": \"発言者名（敬称なし）\",\n            \"speech_content\": \"発言内容\",\n            \"chapter_number\": 1,\n            \"sub_chapter_number\": 1,\n            \"speech_order\": 1\n          },\n          {\n            \"speaker\": \"次の発言者名\",\n            \"speech_content\": \"次の発言内容\",\n            \"chapter_number\": 1,\n            \"sub_chapter_number\": 1,\n            \"speech_order\": 2\n          }\n        ]\n\n        重要: \"speech_content\"フィールドを使用してください（\"utterance\", \"speech\"ではありません）\n    \"#\n}\n\n// Function 5: 発言者名を正規化して人名を抽出\nclass NormalizedSpeaker {\n    original_speaker string @description(\"元の発言者名\")\n    normalized_name string @description(\"正規化された人名（役職を除いた人名）\")\n    is_valid bool @description(\"有効な人名かどうか（役職のみでマッピングもない場合はfalse）\")\n    extraction_method string @description(\"抽出方法: pattern（括弧内から抽出）, mapping（マッピングから取得）, as_is（そのまま使用）, skipped（スキップ）\")\n}\n\nfunction NormalizeSpeakerNames(\n    speakers: string[],\n    role_name_mappings: map<string, string>?\n) -> NormalizedSpeaker[] {\n    client Gemini2Flash\n    prompt #\"\n        以下の発言者名リストを正規化し、人名のみを抽出してください。\n        **重要: 入力リストの各要素に対して、必ず1つのNormalizedSpeakerオブジェクトを返してください。**\n\n        発言者名リスト:\n        {{ speakers }}\n\n        役職-人名マッピング（提供されている場合）:\n        {{ role_name_mappings }}\n\n        【処理ルール】優先順位順に適用してください:\n\n        1. **括弧内の人名抽出**（最優先）\n           - 「役職（人名）」または「役職(人名)」形式の場合、括弧内の人名のみを抽出\n           - 例: \"市長（松井一郎）\" → \"松井一郎\"\n           - 例: \"○議長（西村義直君）\" → \"西村義直\"（敬称も除去）\n           - 例: \"委員長（山田太郎議員）\" → \"山田太郎\"\n           - extraction_method: \"pattern\"\n\n        2. **役職のみの場合はマッピング参照**\n           - 役職名のみ（議長、市長、委員長など）でマッピングがある場合は人名を取得\n           - 例: \"市長\" + マッピング{\"市長\": \"松井一郎\"} → \"松井一郎\"\n           - extraction_method: \"mapping\"\n\n        3. **役職のみでマッピングなしはスキップ**\n           - 役職名のみでマッピングがない場合は無効としてマーク\n           - 例: \"市長\"（マッピングなし）→ is_valid: false\n           - extraction_method: \"skipped\"\n\n        4. **人名のみはそのまま使用**\n           - 人名と判断できる場合はそのまま使用\n           - 例: \"西村義直\" → \"西村義直\"\n           - extraction_method: \"as_is\"\n\n        【役職として扱うキーワード】:\n        議長、副議長、委員長、副委員長、会長、副会長、理事、幹事、書記、議員、\n        市長、副市長、町長、副町長、村長、副村長、区長、副区長、知事、副知事、\n        部長、局長、課長、事務局長、事務局次長、\n        参考人、証人、説明員、政府参考人、大臣、副大臣、政務官\n\n        【敬称として除去するもの】:\n        君、氏、議員、委員、参考人、証人、説明員、さん、様、先生\n\n        【注意】:\n        - 記号（○◆◇■□●）は無視してください\n        - 全角括弧（）と半角括弧()の両方に対応してください\n        - 空の発言者名はis_valid: falseとしてください\n\n        【出力形式の例】入力: [\"議長(西村義直)\", \"市長\", \"田中太郎\"]、マッピング: {\"市長\": \"松井一郎\"}\n        出力:\n        [\n          {\"original_speaker\": \"議長(西村義直)\", \"normalized_name\": \"西村義直\", \"is_valid\": true, \"extraction_method\": \"pattern\"},\n          {\"original_speaker\": \"市長\", \"normalized_name\": \"松井一郎\", \"is_valid\": true, \"extraction_method\": \"mapping\"},\n          {\"original_speaker\": \"田中太郎\", \"normalized_name\": \"田中太郎\", \"is_valid\": true, \"extraction_method\": \"as_is\"}\n        ]\n\n        {{ ctx.output_format }}\n    \"#\n}\n\n// Function 6: 長いセクションを再分割\nfunction RedivideSection(section_text: string, divide_counter: int, original_index: int) -> SectionInfo[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のセクションを{{ divide_counter }}個に再分割してください。\n\n        元のインデックス: {{ original_index }}\n\n        セクション内容:\n        {{ section_text }}\n\n        指示:\n        1. セクションを{{ divide_counter }}個の意味のある単位に分割してください\n        2. 各セクションの先頭30文字をキーワードとして抽出してください\n        3. chapter_numberは1から順番に割り振ってください\n        4. キーワードは元の文字列から正確に抽出してください（改変しない）\n\n        注意:\n        - 意味のある区切りで分割してください（発言者の変更、議題の変更など）\n        - キーワードは議事録内に実際に存在する文字列である必要があります\n    \"#\n}\n",
    "page_classifier.baml": "// Page Classification for Sagebase\n// ページ分類用のBAML定義\n\n// ========================================\n// Class Definitions (Pydanticモデルに対応)\n// ========================================\n\n// PageClassification - ページタイプの分類結果\nclass PageClassification {\n    page_type string @description(\"Type of page: index_page, member_list_page, other\")\n    confidence float @description(\"Confidence score (0.0-1.0)\")\n    reason string @description(\"Reason for classification\")\n    has_child_links bool @description(\"Whether the page has child links\")\n    has_member_info bool @description(\"Whether the page has member information\")\n}\n\n// ========================================\n// Function Definitions\n// ========================================\n\n// Function: ページを分類\nfunction ClassifyPage(\n    html_excerpt: string,\n    current_url: string,\n    party_name: string\n) -> PageClassification {\n    client Gemini2Flash\n    prompt #\"\n        以下のWebページを分類してください。\n\n        URL: {{ current_url }}\n        政党名: {{ party_name }}\n\n        HTMLの一部（抜粋）:\n        {{ html_excerpt }}\n\n        タスク:\n        このページを以下のタイプに分類してください:\n        - index_page: インデックスページ（他のページへのリンク集、ナビゲーションページ）\n        - member_list_page: 議員一覧ページ（議員の情報が掲載されているページ）\n        - other: その他のページ\n\n        指示:\n        1. HTMLの内容から適切なページタイプを判定してください\n        2. has_child_links: このページに子ページへのリンクがあるかを判定（true/false）\n        3. has_member_info: このページに議員情報が含まれているかを判定（true/false）\n        4. confidence: 分類の確信度を0.0-1.0で表してください\n        5. reason: 判定理由を簡潔に説明してください（日本語で）\n\n        判定のポイント:\n        - インデックスページ: 「都道府県一覧」「支部一覧」「地域別」などのナビゲーションリンクが多い\n        - 議員一覧ページ: 議員名、役職、連絡先、プロフィールなどの情報が複数含まれている\n        - その他: 上記に該当しない一般的なページ\n\n        注意:\n        - URLやHTMLの構造から総合的に判断してください\n        - 政党名も判定の参考にしてください\n        - HTMLは抜粋なので、完全な情報がない場合もあります\n\n        出力形式（JSON）:\n        {\n          \"page_type\": \"index_page\",\n          \"confidence\": 0.92,\n          \"reason\": \"「都道府県別」「支部一覧」などのナビゲーションリンクが多数含まれているため、インデックスページと判断\",\n          \"has_child_links\": true,\n          \"has_member_info\": false\n        }\n    \"#\n}\n",
    "parliamentary_group_member_extractor.baml": "// Parliamentary Group Member Extraction for Sagebase\n// 議員団メンバー抽出用のBAML定義\n\n// 抽出された議員団メンバー情報の型定義\nclass ParliamentaryGroupMember {\n    name string @description(\"議員名（フルネーム）\")\n    role string? @description(\"役職（団長、幹事長、政調会長など）\")\n    party_name string? @description(\"所属政党名\")\n    district string? @description(\"選挙区\")\n    additional_info string? @description(\"その他の情報\")\n}\n\n// 議員団メンバー抽出関数\nfunction ExtractParliamentaryGroupMembers(\n    html: string,\n    text_content: string\n) -> ParliamentaryGroupMember[] {\n    client Gemini2Flash\n    prompt #\"\n        以下のWebページから議員団に所属する議員の情報を抽出してください。\n\n        各議員について以下の情報を抽出:\n        1. 議員の氏名（必須、フルネーム）\n        2. 議員団内での役職（団長、幹事長、政調会長など）\n        3. 所属政党名（議員団名とは異なる場合のみ）\n        4. 選挙区\n        5. その他の重要な情報\n\n        注意事項:\n        - 議員団（会派）のメンバー一覧を抽出してください\n        - 役職者だけでなく、一般のメンバーも含めて全員を抽出してください\n        - 名前の表記は元のページの表記を維持してください\n        - 敬称（議員、氏、さん、様、先生など）は除外してください\n        - 議員団名と政党名は異なる場合があります（例：「○○会派」と「△△党」）\n        - 役職がない場合はnullとしてください\n        - 所属政党が明記されていない場合はnullとしてください\n\n        **重要: 必ず以下の英語フィールド名でJSONを返してください:**\n        - name: 議員名\n        - role: 役職\n        - party_name: 所属政党名\n        - district: 選挙区\n        - additional_info: その他の情報\n\n        テキストコンテンツ:\n        {{ text_content }}\n\n        HTMLコンテンツ（構造の参考用）:\n        {{ html }}\n\n        上記の情報から、議員団メンバー全員の情報を抽出してください。\n    \"#\n}\n",
    "politician_matching.baml": "// Politician Matching for Sagebase\n// 政治家マッチング用のBAML定義\n\n// ========================================\n// Class Definitions (Pydanticモデルに対応)\n// ========================================\n\n// PoliticianMatch - 政治家マッチング結果\nclass PoliticianMatch {\n    matched bool @description(\"マッチングが成功したか\")\n    politician_id int? @description(\"マッチした政治家のID（マッチしない場合はnull）\")\n    politician_name string? @description(\"マッチした政治家の名前（マッチしない場合はnull）\")\n    political_party_name string? @description(\"所属政党名（マッチしない場合はnull）\")\n    confidence float @description(\"マッチングの信頼度（0.0-1.0）\")\n    reason string @description(\"マッチング判定の理由\")\n}\n\n// ========================================\n// Function Definitions\n// ========================================\n\n// Function: 政治家マッチング\nfunction MatchPolitician(\n    speaker_name: string,\n    speaker_type: string,\n    speaker_party: string,\n    available_politicians: string\n) -> PoliticianMatch {\n    client Gemini2Flash\n    prompt #\"\n        あなたは発言者と政治家のマッチング専門家です。\n        発言者情報と既存の政治家リストから最も適切なマッチを見つけてください。\n\n        # 発言者情報\n        名前: {{ speaker_name }}\n        種別: {{ speaker_type }}\n        所属政党: {{ speaker_party }}\n\n        # 候補となる政治家リスト\n        {{ available_politicians }}\n\n        # マッチング基準\n        1. 氏名の完全一致を最優先\n        2. 所属政党が一致する場合は信頼度を上げる\n        3. 表記ゆれを考慮（例: \"斉藤\" と \"齊藤\"）\n        4. 同姓同名の場合は政党や役職で判断\n        5. 部分一致や音韻的類似性\n\n        # 信頼度の基準\n        - 0.9以上: 氏名と政党が完全一致\n        - 0.7-0.9: 氏名は一致するが政党が不明または部分一致\n        - 0.5-0.7: 氏名に表記ゆれがあるが政党は一致\n        - 0.5未満: マッチング不可（matched: false）\n\n        # 出力要件\n        - 確実性が低い場合は matched: false を返す\n        - confidence は 0.7 以上の場合のみマッチとして扱う\n        - マッチしない場合は politician_id, politician_name, political_party_name を null に設定\n\n        # 重要\n        - 信頼度が0.7未満の場合は、必ず matched: false を返してください。\n        - **必ず**指定された形式のJSONで出力してください。自然言語での説明は禁止です。\n        - 役職名のみの入力（例：「委員長」「副議長」「事務局長」）は個人を特定できないため、\n          matched: false, confidence: 0.0, reason: \"役職名のみのため個人を特定できません\" を返してください。\n        - マッチする政治家がいない場合も、必ず構造化された形式で出力してください。\n\n        # 出力形式（この形式に厳密に従ってください）\n        マッチ成功の場合:\n        {\n          \"matched\": true,\n          \"politician_id\": <政治家ID>,\n          \"politician_name\": \"<政治家名>\",\n          \"political_party_name\": \"<政党名>\",\n          \"confidence\": <0.0-1.0>,\n          \"reason\": \"<マッチング判定の理由を必ず記述>\"\n        }\n\n        マッチ失敗の場合:\n        {\n          \"matched\": false,\n          \"politician_id\": null,\n          \"politician_name\": null,\n          \"political_party_name\": null,\n          \"confidence\": <0.0-1.0>,\n          \"reason\": \"<マッチしない理由を必ず記述>\"\n        }\n\n        {{ ctx.output_format }}\n    \"#\n}\n",
    "resume.baml": "// Defining a data model.\nclass Resume {\n  name string\n  email string\n  experience string[]\n  skills string[]\n}\n\n// Create a function to extract the resume from a string.\nfunction ExtractResume(resume: string) -> Resume {\n  // Specify a client as provider/model-name\n  // You can also use custom LLM params with a custom client name from clients.baml like \"client CustomGPT5\" or \"client CustomSonnet4\"\n  client \"openai-responses/gpt-5-mini\" // Set OPENAI_API_KEY to use this client.\n  prompt #\"\n    Extract from this content:\n    {{ resume }}\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n\n\n// Test the function with a sample resume. Open the VSCode playground to run this.\ntest vaibhav_resume {\n  functions [ExtractResume]\n  args {\n    resume #\"\n      Vaibhav Gupta\n      vbv@boundaryml.com\n\n      Experience:\n      - Founder at BoundaryML\n      - CV Engineer at Google\n      - CV Engineer at Microsoft\n\n      Skills:\n      - Rust\n      - C++\n    \"#\n  }\n}\n",
    "role_name_mapping.baml": "// Role Name Mapping for Sagebase\n// 役職-人名マッピング抽出用のBAML定義\n\n// ========================================\n// Class Definitions\n// ========================================\n\n// 役職と人名のマッピング\nclass RoleNameMapping {\n    role string @description(\"役職名（例: 議長、副議長、知事、委員長）\")\n    name string @description(\"人名（例: 伊藤条一、梶谷大志）。敬称は除外すること\")\n    member_number string? @description(\"議員番号（あれば。例: 100番、82番）\")\n}\n\n// 役職-人名マッピング抽出結果\nclass RoleNameMappingResult {\n    mappings RoleNameMapping[] @description(\"役職と人名のマッピングリスト\")\n    attendee_section_found bool @description(\"出席者セクションが見つかったか\")\n    confidence float @description(\"抽出の信頼度（0.0-1.0）\")\n}\n\n// ========================================\n// Function Definitions\n// ========================================\n\n// 出席者情報から役職-人名マッピングを抽出\nfunction ExtractRoleNameMapping(\n    attendee_text: string\n) -> RoleNameMappingResult {\n    client Gemini2Flash\n    prompt #\"\n        以下の議事録の出席者情報から、役職と人名の対応を抽出してください。\n\n        出席者情報:\n        {{ attendee_text }}\n\n        # 抽出対象\n        1. 役職名（議長、副議長、知事、副知事、委員長、副委員長など）\n        2. その役職に対応する人名（敬称は除外）\n        3. 議員番号（記載がある場合のみ）\n\n        # 注意事項\n        - 人名は姓名を正確に抽出してください\n        - 敬称（議員、氏、さん、様、先生、君など）は除外してください\n        - 役職のない一般出席者は含めないでください\n        - 「出席議員」セクション全体ではなく、役職が明記されている人のみを抽出してください\n        - 同じ人物が複数の役職を持つ場合は、両方のマッピングを作成してください\n\n        # 出席者セクションの判定\n        - 「出席議員」「出席説明員」「出席者」などのセクションが見つかった場合: attendee_section_found = true\n        - 出席者情報が見つからない場合: attendee_section_found = false\n\n        # 信頼度の基準\n        - 0.9以上: 明確な役職-人名の対応が複数見つかった\n        - 0.7-0.9: 役職-人名の対応が見つかったが、一部不明確\n        - 0.5-0.7: 出席者情報は見つかったが、役職の対応が不明確\n        - 0.5未満: 出席者情報がほとんど見つからない\n\n        # 出力形式\n        出席者セクションが見つかった場合:\n        {\n          \"mappings\": [\n            {\"role\": \"議長\", \"name\": \"伊藤条一\", \"member_number\": \"100番\"},\n            {\"role\": \"副議長\", \"name\": \"梶谷大志\", \"member_number\": \"82番\"},\n            {\"role\": \"知事\", \"name\": \"鈴木直道\", \"member_number\": null}\n          ],\n          \"attendee_section_found\": true,\n          \"confidence\": 0.95\n        }\n\n        出席者セクションが見つからない場合:\n        {\n          \"mappings\": [],\n          \"attendee_section_found\": false,\n          \"confidence\": 0.0\n        }\n\n        {{ ctx.output_format }}\n    \"#\n}\n",
}

def get_baml_files():
    return _file_map
